<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>socket 模块 | Kevin-Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/kevin-blog/logo.png">
    <meta name="description" content="">
    <link rel="preload" href="/kevin-blog/assets/css/0.styles.267bc68b.css" as="style"><link rel="preload" href="/kevin-blog/assets/js/app.dd46475d.js" as="script"><link rel="preload" href="/kevin-blog/assets/js/2.97d04891.js" as="script"><link rel="preload" href="/kevin-blog/assets/js/222.e39491a9.js" as="script"><link rel="prefetch" href="/kevin-blog/assets/js/10.2b686438.js"><link rel="prefetch" href="/kevin-blog/assets/js/100.cfc5acd5.js"><link rel="prefetch" href="/kevin-blog/assets/js/101.628bd39e.js"><link rel="prefetch" href="/kevin-blog/assets/js/102.41585307.js"><link rel="prefetch" href="/kevin-blog/assets/js/103.5d18350a.js"><link rel="prefetch" href="/kevin-blog/assets/js/104.85cd65cf.js"><link rel="prefetch" href="/kevin-blog/assets/js/105.9d303bac.js"><link rel="prefetch" href="/kevin-blog/assets/js/106.73f6a263.js"><link rel="prefetch" href="/kevin-blog/assets/js/107.9dfe114c.js"><link rel="prefetch" href="/kevin-blog/assets/js/108.315e8c63.js"><link rel="prefetch" href="/kevin-blog/assets/js/109.ef21ffa0.js"><link rel="prefetch" href="/kevin-blog/assets/js/11.2b0f6358.js"><link rel="prefetch" href="/kevin-blog/assets/js/110.dfe062a3.js"><link rel="prefetch" href="/kevin-blog/assets/js/111.08f0c3e7.js"><link rel="prefetch" href="/kevin-blog/assets/js/112.0e180f10.js"><link rel="prefetch" href="/kevin-blog/assets/js/113.295f1fca.js"><link rel="prefetch" href="/kevin-blog/assets/js/114.5645d09d.js"><link rel="prefetch" href="/kevin-blog/assets/js/115.ebe19212.js"><link rel="prefetch" href="/kevin-blog/assets/js/116.b3eb5cab.js"><link rel="prefetch" href="/kevin-blog/assets/js/117.076c6372.js"><link rel="prefetch" href="/kevin-blog/assets/js/118.226fb513.js"><link rel="prefetch" href="/kevin-blog/assets/js/119.298c0302.js"><link rel="prefetch" href="/kevin-blog/assets/js/12.01390043.js"><link rel="prefetch" href="/kevin-blog/assets/js/120.943d0d71.js"><link rel="prefetch" href="/kevin-blog/assets/js/121.2d1bd8ef.js"><link rel="prefetch" href="/kevin-blog/assets/js/122.84b9dff1.js"><link rel="prefetch" href="/kevin-blog/assets/js/123.85d93d87.js"><link rel="prefetch" href="/kevin-blog/assets/js/124.4913aefd.js"><link rel="prefetch" href="/kevin-blog/assets/js/125.cf667169.js"><link rel="prefetch" href="/kevin-blog/assets/js/126.eefd3250.js"><link rel="prefetch" href="/kevin-blog/assets/js/127.f9697daf.js"><link rel="prefetch" href="/kevin-blog/assets/js/128.aff6033d.js"><link rel="prefetch" href="/kevin-blog/assets/js/129.fa7ec9a8.js"><link rel="prefetch" href="/kevin-blog/assets/js/13.e55a4126.js"><link rel="prefetch" href="/kevin-blog/assets/js/130.9d50b78d.js"><link rel="prefetch" href="/kevin-blog/assets/js/131.f384aa34.js"><link rel="prefetch" href="/kevin-blog/assets/js/132.e60091dc.js"><link rel="prefetch" href="/kevin-blog/assets/js/133.09a9de16.js"><link rel="prefetch" href="/kevin-blog/assets/js/134.a7739a99.js"><link rel="prefetch" href="/kevin-blog/assets/js/135.bea491db.js"><link rel="prefetch" href="/kevin-blog/assets/js/136.92af3a82.js"><link rel="prefetch" href="/kevin-blog/assets/js/137.dbda7b02.js"><link rel="prefetch" href="/kevin-blog/assets/js/138.9fea4ca4.js"><link rel="prefetch" href="/kevin-blog/assets/js/139.0a81aff9.js"><link rel="prefetch" href="/kevin-blog/assets/js/14.efd69f3b.js"><link rel="prefetch" href="/kevin-blog/assets/js/140.3f048218.js"><link rel="prefetch" href="/kevin-blog/assets/js/141.002d7568.js"><link rel="prefetch" href="/kevin-blog/assets/js/142.aec10062.js"><link rel="prefetch" href="/kevin-blog/assets/js/143.2e682c5b.js"><link rel="prefetch" href="/kevin-blog/assets/js/144.d05092f0.js"><link rel="prefetch" href="/kevin-blog/assets/js/145.358437b8.js"><link rel="prefetch" href="/kevin-blog/assets/js/146.af219f24.js"><link rel="prefetch" href="/kevin-blog/assets/js/147.061cb5fe.js"><link rel="prefetch" href="/kevin-blog/assets/js/148.422d1f87.js"><link rel="prefetch" href="/kevin-blog/assets/js/149.c97f27f4.js"><link rel="prefetch" href="/kevin-blog/assets/js/15.271f58eb.js"><link rel="prefetch" href="/kevin-blog/assets/js/150.177533a9.js"><link rel="prefetch" href="/kevin-blog/assets/js/151.d70f314c.js"><link rel="prefetch" href="/kevin-blog/assets/js/152.ca40e6fc.js"><link rel="prefetch" href="/kevin-blog/assets/js/153.a2bca317.js"><link rel="prefetch" href="/kevin-blog/assets/js/154.22edbf9f.js"><link rel="prefetch" href="/kevin-blog/assets/js/155.e59b2d87.js"><link rel="prefetch" href="/kevin-blog/assets/js/156.d5a38de8.js"><link rel="prefetch" href="/kevin-blog/assets/js/157.cbe5199a.js"><link rel="prefetch" href="/kevin-blog/assets/js/158.31c5b8b2.js"><link rel="prefetch" href="/kevin-blog/assets/js/159.0763ed0c.js"><link rel="prefetch" href="/kevin-blog/assets/js/16.e92cdd55.js"><link rel="prefetch" href="/kevin-blog/assets/js/160.a05ced02.js"><link rel="prefetch" href="/kevin-blog/assets/js/161.7e52ed13.js"><link rel="prefetch" href="/kevin-blog/assets/js/162.f5df7208.js"><link rel="prefetch" href="/kevin-blog/assets/js/163.78a78de8.js"><link rel="prefetch" href="/kevin-blog/assets/js/164.54fd347c.js"><link rel="prefetch" href="/kevin-blog/assets/js/165.a0347ed3.js"><link rel="prefetch" href="/kevin-blog/assets/js/166.0702e96e.js"><link rel="prefetch" href="/kevin-blog/assets/js/167.69136cd0.js"><link rel="prefetch" href="/kevin-blog/assets/js/168.d0aa7e0d.js"><link rel="prefetch" href="/kevin-blog/assets/js/169.6229f0ca.js"><link rel="prefetch" href="/kevin-blog/assets/js/17.9a006e5d.js"><link rel="prefetch" href="/kevin-blog/assets/js/170.b6571721.js"><link rel="prefetch" href="/kevin-blog/assets/js/171.600f9683.js"><link rel="prefetch" href="/kevin-blog/assets/js/172.6e1792a7.js"><link rel="prefetch" href="/kevin-blog/assets/js/173.cef126b3.js"><link rel="prefetch" href="/kevin-blog/assets/js/174.97b3e897.js"><link rel="prefetch" href="/kevin-blog/assets/js/175.fcefca30.js"><link rel="prefetch" href="/kevin-blog/assets/js/176.31862a66.js"><link rel="prefetch" href="/kevin-blog/assets/js/177.089b09c0.js"><link rel="prefetch" href="/kevin-blog/assets/js/178.a5dcd25c.js"><link rel="prefetch" href="/kevin-blog/assets/js/179.a9d685f2.js"><link rel="prefetch" href="/kevin-blog/assets/js/18.a1c24192.js"><link rel="prefetch" href="/kevin-blog/assets/js/180.4ad69266.js"><link rel="prefetch" href="/kevin-blog/assets/js/181.691d48a2.js"><link rel="prefetch" href="/kevin-blog/assets/js/182.e77aa679.js"><link rel="prefetch" href="/kevin-blog/assets/js/183.2b4341f4.js"><link rel="prefetch" href="/kevin-blog/assets/js/184.b3610e8b.js"><link rel="prefetch" href="/kevin-blog/assets/js/185.08107897.js"><link rel="prefetch" href="/kevin-blog/assets/js/186.9f5a3f65.js"><link rel="prefetch" href="/kevin-blog/assets/js/187.ac2fe2c2.js"><link rel="prefetch" href="/kevin-blog/assets/js/188.09023a78.js"><link rel="prefetch" href="/kevin-blog/assets/js/189.409b4ed0.js"><link rel="prefetch" href="/kevin-blog/assets/js/19.c733cdfe.js"><link rel="prefetch" href="/kevin-blog/assets/js/190.ca5d775c.js"><link rel="prefetch" href="/kevin-blog/assets/js/191.8052fe42.js"><link rel="prefetch" href="/kevin-blog/assets/js/192.31ebe059.js"><link rel="prefetch" href="/kevin-blog/assets/js/193.9bf32e11.js"><link rel="prefetch" href="/kevin-blog/assets/js/194.0667554a.js"><link rel="prefetch" href="/kevin-blog/assets/js/195.ea249ba4.js"><link rel="prefetch" href="/kevin-blog/assets/js/196.6278ec5a.js"><link rel="prefetch" href="/kevin-blog/assets/js/197.90f6af7b.js"><link rel="prefetch" href="/kevin-blog/assets/js/198.2e358b6a.js"><link rel="prefetch" href="/kevin-blog/assets/js/199.a0bd0085.js"><link rel="prefetch" href="/kevin-blog/assets/js/20.890583ea.js"><link rel="prefetch" href="/kevin-blog/assets/js/200.bc1e237a.js"><link rel="prefetch" href="/kevin-blog/assets/js/201.767e166e.js"><link rel="prefetch" href="/kevin-blog/assets/js/202.a52f0e94.js"><link rel="prefetch" href="/kevin-blog/assets/js/203.06f0ebab.js"><link rel="prefetch" href="/kevin-blog/assets/js/204.7ae45191.js"><link rel="prefetch" href="/kevin-blog/assets/js/205.b8412fbc.js"><link rel="prefetch" href="/kevin-blog/assets/js/206.682f9a3e.js"><link rel="prefetch" href="/kevin-blog/assets/js/207.8978346c.js"><link rel="prefetch" href="/kevin-blog/assets/js/208.35db8c05.js"><link rel="prefetch" href="/kevin-blog/assets/js/209.1eebeab0.js"><link rel="prefetch" href="/kevin-blog/assets/js/21.48328b6a.js"><link rel="prefetch" href="/kevin-blog/assets/js/210.b56db64f.js"><link rel="prefetch" href="/kevin-blog/assets/js/211.31da36f5.js"><link rel="prefetch" href="/kevin-blog/assets/js/212.2f2d2d1f.js"><link rel="prefetch" href="/kevin-blog/assets/js/213.be55b8cc.js"><link rel="prefetch" href="/kevin-blog/assets/js/214.aeffc247.js"><link rel="prefetch" href="/kevin-blog/assets/js/215.137bae15.js"><link rel="prefetch" href="/kevin-blog/assets/js/216.2692c636.js"><link rel="prefetch" href="/kevin-blog/assets/js/217.a6a9cf62.js"><link rel="prefetch" href="/kevin-blog/assets/js/218.7353ed7a.js"><link rel="prefetch" href="/kevin-blog/assets/js/219.f1fdfe8e.js"><link rel="prefetch" href="/kevin-blog/assets/js/22.5fd865e7.js"><link rel="prefetch" href="/kevin-blog/assets/js/220.e20ab2b5.js"><link rel="prefetch" href="/kevin-blog/assets/js/221.0d06c8b0.js"><link rel="prefetch" href="/kevin-blog/assets/js/223.ae98df72.js"><link rel="prefetch" href="/kevin-blog/assets/js/224.4ba5d334.js"><link rel="prefetch" href="/kevin-blog/assets/js/225.913ee059.js"><link rel="prefetch" href="/kevin-blog/assets/js/226.b8d730bd.js"><link rel="prefetch" href="/kevin-blog/assets/js/227.69ee92e2.js"><link rel="prefetch" href="/kevin-blog/assets/js/228.1cf17cff.js"><link rel="prefetch" href="/kevin-blog/assets/js/229.6ce44fac.js"><link rel="prefetch" href="/kevin-blog/assets/js/23.9ef4ab20.js"><link rel="prefetch" href="/kevin-blog/assets/js/230.30c28e05.js"><link rel="prefetch" href="/kevin-blog/assets/js/231.ef327150.js"><link rel="prefetch" href="/kevin-blog/assets/js/232.6cb791d8.js"><link rel="prefetch" href="/kevin-blog/assets/js/233.473fa94b.js"><link rel="prefetch" href="/kevin-blog/assets/js/234.848de787.js"><link rel="prefetch" href="/kevin-blog/assets/js/235.f5db4ed9.js"><link rel="prefetch" href="/kevin-blog/assets/js/236.5da3f87c.js"><link rel="prefetch" href="/kevin-blog/assets/js/237.018a543d.js"><link rel="prefetch" href="/kevin-blog/assets/js/238.74d22845.js"><link rel="prefetch" href="/kevin-blog/assets/js/239.fca187a6.js"><link rel="prefetch" href="/kevin-blog/assets/js/24.3dff5faa.js"><link rel="prefetch" href="/kevin-blog/assets/js/240.0dbbfe84.js"><link rel="prefetch" href="/kevin-blog/assets/js/241.8b1ccf29.js"><link rel="prefetch" href="/kevin-blog/assets/js/242.f5216a9f.js"><link rel="prefetch" href="/kevin-blog/assets/js/243.8e5c5e34.js"><link rel="prefetch" href="/kevin-blog/assets/js/244.8f78ae9a.js"><link rel="prefetch" href="/kevin-blog/assets/js/245.e0b2e7b9.js"><link rel="prefetch" href="/kevin-blog/assets/js/246.7700207e.js"><link rel="prefetch" href="/kevin-blog/assets/js/247.c1e13b57.js"><link rel="prefetch" href="/kevin-blog/assets/js/248.63d6adf8.js"><link rel="prefetch" href="/kevin-blog/assets/js/249.500fdd00.js"><link rel="prefetch" href="/kevin-blog/assets/js/25.0ebddc27.js"><link rel="prefetch" href="/kevin-blog/assets/js/250.ebbb5c92.js"><link rel="prefetch" href="/kevin-blog/assets/js/251.4e51605e.js"><link rel="prefetch" href="/kevin-blog/assets/js/252.2534bb33.js"><link rel="prefetch" href="/kevin-blog/assets/js/253.330d0073.js"><link rel="prefetch" href="/kevin-blog/assets/js/254.da99904b.js"><link rel="prefetch" href="/kevin-blog/assets/js/255.f9a1774e.js"><link rel="prefetch" href="/kevin-blog/assets/js/256.7ee8ac66.js"><link rel="prefetch" href="/kevin-blog/assets/js/257.41594669.js"><link rel="prefetch" href="/kevin-blog/assets/js/258.9d8beffc.js"><link rel="prefetch" href="/kevin-blog/assets/js/259.1539043a.js"><link rel="prefetch" href="/kevin-blog/assets/js/26.7e91ac9d.js"><link rel="prefetch" href="/kevin-blog/assets/js/260.034695f0.js"><link rel="prefetch" href="/kevin-blog/assets/js/261.953910a0.js"><link rel="prefetch" href="/kevin-blog/assets/js/262.e2b0764f.js"><link rel="prefetch" href="/kevin-blog/assets/js/263.fe9b0b70.js"><link rel="prefetch" href="/kevin-blog/assets/js/264.489e20f7.js"><link rel="prefetch" href="/kevin-blog/assets/js/265.43596b34.js"><link rel="prefetch" href="/kevin-blog/assets/js/266.07bb7008.js"><link rel="prefetch" href="/kevin-blog/assets/js/267.5caf5b93.js"><link rel="prefetch" href="/kevin-blog/assets/js/268.fc6e09e2.js"><link rel="prefetch" href="/kevin-blog/assets/js/269.764500c0.js"><link rel="prefetch" href="/kevin-blog/assets/js/27.55c7093f.js"><link rel="prefetch" href="/kevin-blog/assets/js/270.9760648a.js"><link rel="prefetch" href="/kevin-blog/assets/js/271.019b1f9a.js"><link rel="prefetch" href="/kevin-blog/assets/js/272.bce07ec6.js"><link rel="prefetch" href="/kevin-blog/assets/js/273.038ff1e3.js"><link rel="prefetch" href="/kevin-blog/assets/js/274.2cb7fd59.js"><link rel="prefetch" href="/kevin-blog/assets/js/275.3c831af6.js"><link rel="prefetch" href="/kevin-blog/assets/js/276.8d0732f8.js"><link rel="prefetch" href="/kevin-blog/assets/js/277.5aa0c664.js"><link rel="prefetch" href="/kevin-blog/assets/js/278.a3cdd3b8.js"><link rel="prefetch" href="/kevin-blog/assets/js/279.d049a479.js"><link rel="prefetch" href="/kevin-blog/assets/js/28.da28db4a.js"><link rel="prefetch" href="/kevin-blog/assets/js/280.6b7f68c4.js"><link rel="prefetch" href="/kevin-blog/assets/js/281.eff251cb.js"><link rel="prefetch" href="/kevin-blog/assets/js/282.f0dc7866.js"><link rel="prefetch" href="/kevin-blog/assets/js/283.36ca2fb9.js"><link rel="prefetch" href="/kevin-blog/assets/js/284.470e6db4.js"><link rel="prefetch" href="/kevin-blog/assets/js/285.a9c60b36.js"><link rel="prefetch" href="/kevin-blog/assets/js/286.3eff6f51.js"><link rel="prefetch" href="/kevin-blog/assets/js/287.f406cf63.js"><link rel="prefetch" href="/kevin-blog/assets/js/288.d6bb5731.js"><link rel="prefetch" href="/kevin-blog/assets/js/289.518409f3.js"><link rel="prefetch" href="/kevin-blog/assets/js/29.37ea8137.js"><link rel="prefetch" href="/kevin-blog/assets/js/290.e4795980.js"><link rel="prefetch" href="/kevin-blog/assets/js/291.6ca97e3d.js"><link rel="prefetch" href="/kevin-blog/assets/js/292.f434852f.js"><link rel="prefetch" href="/kevin-blog/assets/js/293.256f39e1.js"><link rel="prefetch" href="/kevin-blog/assets/js/294.0e051edc.js"><link rel="prefetch" href="/kevin-blog/assets/js/295.d6a1cfbb.js"><link rel="prefetch" href="/kevin-blog/assets/js/296.9a3f4bb2.js"><link rel="prefetch" href="/kevin-blog/assets/js/297.374bbc2d.js"><link rel="prefetch" href="/kevin-blog/assets/js/298.c37b0145.js"><link rel="prefetch" href="/kevin-blog/assets/js/299.008098d2.js"><link rel="prefetch" href="/kevin-blog/assets/js/3.0c6053de.js"><link rel="prefetch" href="/kevin-blog/assets/js/30.24e20f30.js"><link rel="prefetch" href="/kevin-blog/assets/js/300.ab07139a.js"><link rel="prefetch" href="/kevin-blog/assets/js/301.69ee5ffa.js"><link rel="prefetch" href="/kevin-blog/assets/js/302.05af46d8.js"><link rel="prefetch" href="/kevin-blog/assets/js/303.cec1cf65.js"><link rel="prefetch" href="/kevin-blog/assets/js/304.7c82ba6c.js"><link rel="prefetch" href="/kevin-blog/assets/js/305.7ac25f4a.js"><link rel="prefetch" href="/kevin-blog/assets/js/306.82149841.js"><link rel="prefetch" href="/kevin-blog/assets/js/307.f56afc9c.js"><link rel="prefetch" href="/kevin-blog/assets/js/308.7c084ed0.js"><link rel="prefetch" href="/kevin-blog/assets/js/309.feb89623.js"><link rel="prefetch" href="/kevin-blog/assets/js/31.19d1e3af.js"><link rel="prefetch" href="/kevin-blog/assets/js/310.1e33889a.js"><link rel="prefetch" href="/kevin-blog/assets/js/311.416e7d20.js"><link rel="prefetch" href="/kevin-blog/assets/js/312.ee11dbec.js"><link rel="prefetch" href="/kevin-blog/assets/js/313.f58bb112.js"><link rel="prefetch" href="/kevin-blog/assets/js/314.543b2b1c.js"><link rel="prefetch" href="/kevin-blog/assets/js/315.18b9a70e.js"><link rel="prefetch" href="/kevin-blog/assets/js/316.6dfba854.js"><link rel="prefetch" href="/kevin-blog/assets/js/317.19590777.js"><link rel="prefetch" href="/kevin-blog/assets/js/318.a3ec0c19.js"><link rel="prefetch" href="/kevin-blog/assets/js/319.f990a61a.js"><link rel="prefetch" href="/kevin-blog/assets/js/32.07887ecb.js"><link rel="prefetch" href="/kevin-blog/assets/js/320.a3c5cbbf.js"><link rel="prefetch" href="/kevin-blog/assets/js/321.1f58e49c.js"><link rel="prefetch" href="/kevin-blog/assets/js/322.032ff5a2.js"><link rel="prefetch" href="/kevin-blog/assets/js/323.cdd3ba68.js"><link rel="prefetch" href="/kevin-blog/assets/js/324.5238a4e1.js"><link rel="prefetch" href="/kevin-blog/assets/js/325.df06c071.js"><link rel="prefetch" href="/kevin-blog/assets/js/33.9539a78e.js"><link rel="prefetch" href="/kevin-blog/assets/js/34.fa08dd12.js"><link rel="prefetch" href="/kevin-blog/assets/js/35.d6823664.js"><link rel="prefetch" href="/kevin-blog/assets/js/36.5e074071.js"><link rel="prefetch" href="/kevin-blog/assets/js/37.f4a65a95.js"><link rel="prefetch" href="/kevin-blog/assets/js/38.4f127420.js"><link rel="prefetch" href="/kevin-blog/assets/js/39.a5427f94.js"><link rel="prefetch" href="/kevin-blog/assets/js/4.a60d4c06.js"><link rel="prefetch" href="/kevin-blog/assets/js/40.859a530c.js"><link rel="prefetch" href="/kevin-blog/assets/js/41.b61d8247.js"><link rel="prefetch" href="/kevin-blog/assets/js/42.cd204014.js"><link rel="prefetch" href="/kevin-blog/assets/js/43.8076c8fc.js"><link rel="prefetch" href="/kevin-blog/assets/js/44.8a85cf72.js"><link rel="prefetch" href="/kevin-blog/assets/js/45.f46f354b.js"><link rel="prefetch" href="/kevin-blog/assets/js/46.5990e5be.js"><link rel="prefetch" href="/kevin-blog/assets/js/47.9381b746.js"><link rel="prefetch" href="/kevin-blog/assets/js/48.77d95473.js"><link rel="prefetch" href="/kevin-blog/assets/js/49.fc6dff0d.js"><link rel="prefetch" href="/kevin-blog/assets/js/5.6b8c7ebc.js"><link rel="prefetch" href="/kevin-blog/assets/js/50.297dac6d.js"><link rel="prefetch" href="/kevin-blog/assets/js/51.c6ed15a6.js"><link rel="prefetch" href="/kevin-blog/assets/js/52.8bb5ec6f.js"><link rel="prefetch" href="/kevin-blog/assets/js/53.32ab5818.js"><link rel="prefetch" href="/kevin-blog/assets/js/54.1fe541f9.js"><link rel="prefetch" href="/kevin-blog/assets/js/55.6084b23b.js"><link rel="prefetch" href="/kevin-blog/assets/js/56.242cd75a.js"><link rel="prefetch" href="/kevin-blog/assets/js/57.a3aa61b8.js"><link rel="prefetch" href="/kevin-blog/assets/js/58.5dc813ec.js"><link rel="prefetch" href="/kevin-blog/assets/js/59.0649b9f5.js"><link rel="prefetch" href="/kevin-blog/assets/js/6.8f60ce79.js"><link rel="prefetch" href="/kevin-blog/assets/js/60.e912e60f.js"><link rel="prefetch" href="/kevin-blog/assets/js/61.2348484b.js"><link rel="prefetch" href="/kevin-blog/assets/js/62.43b03d30.js"><link rel="prefetch" href="/kevin-blog/assets/js/63.6e56096d.js"><link rel="prefetch" href="/kevin-blog/assets/js/64.c45908b4.js"><link rel="prefetch" href="/kevin-blog/assets/js/65.aab0a20e.js"><link rel="prefetch" href="/kevin-blog/assets/js/66.2555ebea.js"><link rel="prefetch" href="/kevin-blog/assets/js/67.80828b1b.js"><link rel="prefetch" href="/kevin-blog/assets/js/68.5b1b38ff.js"><link rel="prefetch" href="/kevin-blog/assets/js/69.d735686b.js"><link rel="prefetch" href="/kevin-blog/assets/js/7.8fc0c0e7.js"><link rel="prefetch" href="/kevin-blog/assets/js/70.fd567fdf.js"><link rel="prefetch" href="/kevin-blog/assets/js/71.3dc39cbd.js"><link rel="prefetch" href="/kevin-blog/assets/js/72.6fe3454c.js"><link rel="prefetch" href="/kevin-blog/assets/js/73.80c96fab.js"><link rel="prefetch" href="/kevin-blog/assets/js/74.7b652913.js"><link rel="prefetch" href="/kevin-blog/assets/js/75.a9cc5506.js"><link rel="prefetch" href="/kevin-blog/assets/js/76.81bca567.js"><link rel="prefetch" href="/kevin-blog/assets/js/77.1851c464.js"><link rel="prefetch" href="/kevin-blog/assets/js/78.06a9be2e.js"><link rel="prefetch" href="/kevin-blog/assets/js/79.89ac9186.js"><link rel="prefetch" href="/kevin-blog/assets/js/8.d7f3575e.js"><link rel="prefetch" href="/kevin-blog/assets/js/80.76b8cfc2.js"><link rel="prefetch" href="/kevin-blog/assets/js/81.7c87b7a7.js"><link rel="prefetch" href="/kevin-blog/assets/js/82.1995f469.js"><link rel="prefetch" href="/kevin-blog/assets/js/83.dd77915d.js"><link rel="prefetch" href="/kevin-blog/assets/js/84.d167dd7d.js"><link rel="prefetch" href="/kevin-blog/assets/js/85.b858e7d4.js"><link rel="prefetch" href="/kevin-blog/assets/js/86.c4508e18.js"><link rel="prefetch" href="/kevin-blog/assets/js/87.e5015ac2.js"><link rel="prefetch" href="/kevin-blog/assets/js/88.03ea7184.js"><link rel="prefetch" href="/kevin-blog/assets/js/89.6c4aecd6.js"><link rel="prefetch" href="/kevin-blog/assets/js/9.541bf307.js"><link rel="prefetch" href="/kevin-blog/assets/js/90.e64c083e.js"><link rel="prefetch" href="/kevin-blog/assets/js/91.208ff0cf.js"><link rel="prefetch" href="/kevin-blog/assets/js/92.0247f769.js"><link rel="prefetch" href="/kevin-blog/assets/js/93.1d51e9e8.js"><link rel="prefetch" href="/kevin-blog/assets/js/94.52fd5e59.js"><link rel="prefetch" href="/kevin-blog/assets/js/95.3641a4fe.js"><link rel="prefetch" href="/kevin-blog/assets/js/96.a96da06a.js"><link rel="prefetch" href="/kevin-blog/assets/js/97.877152bf.js"><link rel="prefetch" href="/kevin-blog/assets/js/98.4fe249c2.js"><link rel="prefetch" href="/kevin-blog/assets/js/99.400d0dc4.js">
    <link rel="stylesheet" href="/kevin-blog/assets/css/0.styles.267bc68b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/kevin-blog/" class="home-link router-link-active"><!----> <span class="site-name">Kevin-Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Web" class="dropdown-title"><span class="title">Web</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/kevin-blog/ES6/Map 数据结构.html" class="nav-link">
  ES6
</a></li></ul></div></div><div class="nav-item"><a href="/kevin-blog/Python/DBUtils 数据库连接池模块.html" class="nav-link">
  Python
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Django" class="dropdown-title"><span class="title">Django</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/kevin-blog/Django/Ajax.html" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/kevin-blog/Django ORM/ORM-ContentType.html" class="nav-link">
  ORM
</a></li><li class="dropdown-item"><!----> <a href="/kevin-blog/Django Rest-Framework/JWT - JSON Web Tokens.html" class="nav-link">
  Rest-Framework
</a></li></ul></div></div><div class="nav-item"><a href="/kevin-blog/Flask/Flask 文件上传.html" class="nav-link">
  Flask
</a></div><div class="nav-item"><a href="/kevin-blog/Git GitHub/Git.html" class="nav-link">
  Git GitHub
</a></div><div class="nav-item"><a href="/kevin-blog/Linux/CentOS 下载和安装.html" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/kevin-blog/MySQL/distinct 去重.html" class="nav-link">
  MySQL
</a></div><div class="nav-item"><a href="/kevin-blog/爬虫/Anaconda环境.html" class="nav-link">
  爬虫
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Web" class="dropdown-title"><span class="title">Web</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/kevin-blog/ES6/Map 数据结构.html" class="nav-link">
  ES6
</a></li></ul></div></div><div class="nav-item"><a href="/kevin-blog/Python/DBUtils 数据库连接池模块.html" class="nav-link">
  Python
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Django" class="dropdown-title"><span class="title">Django</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/kevin-blog/Django/Ajax.html" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/kevin-blog/Django ORM/ORM-ContentType.html" class="nav-link">
  ORM
</a></li><li class="dropdown-item"><!----> <a href="/kevin-blog/Django Rest-Framework/JWT - JSON Web Tokens.html" class="nav-link">
  Rest-Framework
</a></li></ul></div></div><div class="nav-item"><a href="/kevin-blog/Flask/Flask 文件上传.html" class="nav-link">
  Flask
</a></div><div class="nav-item"><a href="/kevin-blog/Git GitHub/Git.html" class="nav-link">
  Git GitHub
</a></div><div class="nav-item"><a href="/kevin-blog/Linux/CentOS 下载和安装.html" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/kevin-blog/MySQL/distinct 去重.html" class="nav-link">
  MySQL
</a></div><div class="nav-item"><a href="/kevin-blog/爬虫/Anaconda环境.html" class="nav-link">
  爬虫
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Python</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/kevin-blog/Python/DBUtils 数据库连接池模块.html" class="sidebar-link">DBUtils 数据库连接池模块</a></li><li><a href="/kevin-blog/Python/IO模型.html" class="sidebar-link">IO模型</a></li><li><a href="/kevin-blog/Python/MySQLdb 模块.html" class="sidebar-link">MySQLdb 模块</a></li><li><a href="/kevin-blog/Python/ORM框架 - SQLAchemy 模块.html" class="sidebar-link">ORM框架 - SQLAchemy 模块</a></li><li><a href="/kevin-blog/Python/PIL 图像处理模块.html" class="sidebar-link">PIL 图像处理模块</a></li><li><a href="/kevin-blog/Python/Python2 和 Python3 的区别.html" class="sidebar-link">Python2 和 Python3 的区别</a></li><li><a href="/kevin-blog/Python/Redis 缓存.html" class="sidebar-link">Redis 缓存</a></li><li><a href="/kevin-blog/Python/SQLAchemy 模块.html" class="sidebar-link">SQLAchemy 模块</a></li><li><a href="/kevin-blog/Python/collections 模块.html" class="sidebar-link">collections 模块</a></li><li><a href="/kevin-blog/Python/configparser 配置文件模块.html" class="sidebar-link">configparser 配置文件模块</a></li><li><a href="/kevin-blog/Python/datetime 时间模块.html" class="sidebar-link">datetime 时间模块</a></li><li><a href="/kevin-blog/Python/hashlib 加密模块.html" class="sidebar-link">hashlib 加密模块</a></li><li><a href="/kevin-blog/Python/hmac 加密模块.html" class="sidebar-link">hmac 加密模块</a></li><li><a href="/kevin-blog/Python/if 条件语句.html" class="sidebar-link">if 条件语句</a></li><li><a href="/kevin-blog/Python/importlib 模块.html" class="sidebar-link">importlib 模块</a></li><li><a href="/kevin-blog/Python/io 模块.html" class="sidebar-link">io 模块</a></li><li><a href="/kevin-blog/Python/logging 日志模块.html" class="sidebar-link">logging 日志模块</a></li><li><a href="/kevin-blog/Python/multiprocessing 进程模块.html" class="sidebar-link">multiprocessing 进程模块</a></li><li><a href="/kevin-blog/Python/os 模块.html" class="sidebar-link">os 模块</a></li><li><a href="/kevin-blog/Python/pipreqs 模块.html" class="sidebar-link">pipreqs 模块</a></li><li><a href="/kevin-blog/Python/pymysql 模块.html" class="sidebar-link">pymysql 模块</a></li><li><a href="/kevin-blog/Python/queue 队列模块.html" class="sidebar-link">queue 队列模块</a></li><li><a href="/kevin-blog/Python/raise 主动抛出异常.html" class="sidebar-link">raise 主动抛出异常</a></li><li><a href="/kevin-blog/Python/random 随机数模块.html" class="sidebar-link">random 随机数模块</a></li><li><a href="/kevin-blog/Python/re 模块.html" class="sidebar-link">re 模块</a></li><li><a href="/kevin-blog/Python/requests 请求模块.html" class="sidebar-link">requests 请求模块</a></li><li><a href="/kevin-blog/Python/select IO多路复用模块.html" class="sidebar-link">select IO多路复用模块</a></li><li><a href="/kevin-blog/Python/socket 模块.html" class="active sidebar-link">socket 模块</a></li><li><a href="/kevin-blog/Python/socketserver 模块.html" class="sidebar-link">socketserver 模块</a></li><li><a href="/kevin-blog/Python/struct 转成固定长度的bytes模块.html" class="sidebar-link">struct 转成固定长度的bytes模块</a></li><li><a href="/kevin-blog/Python/subprocess 执行系统命令模块.html" class="sidebar-link">subprocess 执行系统命令模块</a></li><li><a href="/kevin-blog/Python/sys 模块.html" class="sidebar-link">sys 模块</a></li><li><a href="/kevin-blog/Python/threading 线程模块.html" class="sidebar-link">threading 线程模块</a></li><li><a href="/kevin-blog/Python/time 时间模块.html" class="sidebar-link">time 时间模块</a></li><li><a href="/kevin-blog/Python/uuid 通用唯一识别码模块.html" class="sidebar-link">uuid 通用唯一识别码模块</a></li><li><a href="/kevin-blog/Python/virtualenv 模块.html" class="sidebar-link">virtualenv 模块</a></li><li><a href="/kevin-blog/Python/三元表达式.html" class="sidebar-link">三元表达式</a></li><li><a href="/kevin-blog/Python/使用 Pycharm 的数据库可视化工具.html" class="sidebar-link">使用 Pycharm 的数据库可视化工具</a></li><li><a href="/kevin-blog/Python/偏函数.html" class="sidebar-link">偏函数</a></li><li><a href="/kevin-blog/Python/公共方法.html" class="sidebar-link">公共方法</a></li><li><a href="/kevin-blog/Python/公钥和私钥.html" class="sidebar-link">公钥和私钥</a></li><li><a href="/kevin-blog/Python/内存转换.html" class="sidebar-link">内存转换</a></li><li><a href="/kevin-blog/Python/内置函数.html" class="sidebar-link">内置函数</a></li><li><a href="/kevin-blog/Python/函数.html" class="sidebar-link">函数</a></li><li><a href="/kevin-blog/Python/分别赋值.html" class="sidebar-link">分别赋值</a></li><li><a href="/kevin-blog/Python/包.html" class="sidebar-link">包</a></li><li><a href="/kevin-blog/Python/匿名函数.html" class="sidebar-link">匿名函数</a></li><li><a href="/kevin-blog/Python/协程.html" class="sidebar-link">协程</a></li><li><a href="/kevin-blog/Python/双下方法.html" class="sidebar-link">双下方法</a></li><li><a href="/kevin-blog/Python/反射.html" class="sidebar-link">反射</a></li><li><a href="/kevin-blog/Python/变量 和 常量.html" class="sidebar-link">变量 和 常量</a></li><li><a href="/kevin-blog/Python/命名空间-作用域-作用域链.html" class="sidebar-link">命名空间-作用域-作用域链</a></li><li><a href="/kevin-blog/Python/基础的网络概念.html" class="sidebar-link">基础的网络概念</a></li><li><a href="/kevin-blog/Python/大练习.html" class="sidebar-link">大练习</a></li><li><a href="/kevin-blog/Python/安装第三方模块.html" class="sidebar-link">安装第三方模块</a></li><li><a href="/kevin-blog/Python/并发编程（重要必看）.html" class="sidebar-link">并发编程（重要必看）</a></li><li><a href="/kevin-blog/Python/序列化模块.html" class="sidebar-link">序列化模块</a></li><li><a href="/kevin-blog/Python/开发规范.html" class="sidebar-link">开发规范</a></li><li><a href="/kevin-blog/Python/异常处理.html" class="sidebar-link">异常处理</a></li><li><a href="/kevin-blog/Python/循环删除列表或字典中的值.html" class="sidebar-link">循环删除列表或字典中的值</a></li><li><a href="/kevin-blog/Python/循环语句.html" class="sidebar-link">循环语句</a></li><li><a href="/kevin-blog/Python/报错的查看技巧.html" class="sidebar-link">报错的查看技巧</a></li><li><a href="/kevin-blog/Python/控制台输出带颜色的文字.html" class="sidebar-link">控制台输出带颜色的文字</a></li><li><a href="/kevin-blog/Python/推导式.html" class="sidebar-link">推导式</a></li><li><a href="/kevin-blog/Python/数据类型 dict 字典 方法.html" class="sidebar-link">数据类型 dict 字典 方法</a></li><li><a href="/kevin-blog/Python/数据类型 int 方法.html" class="sidebar-link">数据类型 int 方法</a></li><li><a href="/kevin-blog/Python/数据类型 list 列表 方法.html" class="sidebar-link">数据类型 list 列表 方法</a></li><li><a href="/kevin-blog/Python/数据类型 set 集合 方法.html" class="sidebar-link">数据类型 set 集合 方法</a></li><li><a href="/kevin-blog/Python/数据类型 str 方法.html" class="sidebar-link">数据类型 str 方法</a></li><li><a href="/kevin-blog/Python/数据类型 tuple 元组 方法.html" class="sidebar-link">数据类型 tuple 元组 方法</a></li><li><a href="/kevin-blog/Python/数据类型 和 数据结构.html" class="sidebar-link">数据类型 和 数据结构</a></li><li><a href="/kevin-blog/Python/数据类型的转换.html" class="sidebar-link">数据类型的转换</a></li><li><a href="/kevin-blog/Python/文件操作.html" class="sidebar-link">文件操作</a></li><li><a href="/kevin-blog/Python/条件判断.html" class="sidebar-link">条件判断</a></li><li><a href="/kevin-blog/Python/格式化输出.html" class="sidebar-link">格式化输出</a></li><li><a href="/kevin-blog/Python/模块.html" class="sidebar-link">模块</a></li><li><a href="/kevin-blog/Python/正则表达式.html" class="sidebar-link">正则表达式</a></li><li><a href="/kevin-blog/Python/注释.html" class="sidebar-link">注释</a></li><li><a href="/kevin-blog/Python/深浅 copy().html" class="sidebar-link">深浅 copy()</a></li><li><a href="/kevin-blog/Python/生成器.html" class="sidebar-link">生成器</a></li><li><a href="/kevin-blog/Python/算法.html" class="sidebar-link">算法</a></li><li><a href="/kevin-blog/Python/线程 - Timer 定时器.html" class="sidebar-link">线程 - Timer 定时器</a></li><li><a href="/kevin-blog/Python/线程 - 生产者消费者模型.html" class="sidebar-link">线程 - 生产者消费者模型</a></li><li><a href="/kevin-blog/Python/线程同步 - Condition 条件（了解）.html" class="sidebar-link">线程同步 - Condition 条件（了解）</a></li><li><a href="/kevin-blog/Python/线程同步 - Event 事件（了解）.html" class="sidebar-link">线程同步 - Event 事件（了解）</a></li><li><a href="/kevin-blog/Python/线程同步 - Lock互斥锁.html" class="sidebar-link">线程同步 - Lock互斥锁</a></li><li><a href="/kevin-blog/Python/线程同步 - RLock递归锁.html" class="sidebar-link">线程同步 - RLock递归锁</a></li><li><a href="/kevin-blog/Python/线程同步 - Semaphore 信号量（了解）.html" class="sidebar-link">线程同步 - Semaphore 信号量（了解）</a></li><li><a href="/kevin-blog/Python/线程概念（重要）.html" class="sidebar-link">线程概念（重要）</a></li><li><a href="/kevin-blog/Python/线程池.html" class="sidebar-link">线程池</a></li><li><a href="/kevin-blog/Python/线程间通信 - 队列.html" class="sidebar-link">线程间通信 - 队列</a></li><li><a href="/kevin-blog/Python/编码和解码.html" class="sidebar-link">编码和解码</a></li><li><a href="/kevin-blog/Python/获取页面的内容（代码）.html" class="sidebar-link">获取页面的内容（代码）</a></li><li><a href="/kevin-blog/Python/装饰器.html" class="sidebar-link">装饰器</a></li><li><a href="/kevin-blog/Python/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/kevin-blog/Python/转义.html" class="sidebar-link">转义</a></li><li><a href="/kevin-blog/Python/运算符.html" class="sidebar-link">运算符</a></li><li><a href="/kevin-blog/Python/运行效率.html" class="sidebar-link">运行效率</a></li><li><a href="/kevin-blog/Python/进制.html" class="sidebar-link">进制</a></li><li><a href="/kevin-blog/Python/进程 - 生产者消费者模型.html" class="sidebar-link">进程 - 生产者消费者模型</a></li><li><a href="/kevin-blog/Python/进程同步 - Event 事件（了解）.html" class="sidebar-link">进程同步 - Event 事件（了解）</a></li><li><a href="/kevin-blog/Python/进程同步 - Lock互斥锁.html" class="sidebar-link">进程同步 - Lock互斥锁</a></li><li><a href="/kevin-blog/Python/进程同步 - Semaphore 信号量（了解）.html" class="sidebar-link">进程同步 - Semaphore 信号量（了解）</a></li><li><a href="/kevin-blog/Python/进程概念.html" class="sidebar-link">进程概念</a></li><li><a href="/kevin-blog/Python/进程池.html" class="sidebar-link">进程池</a></li><li><a href="/kevin-blog/Python/进程间通信 - JoinableQueue 队列.html" class="sidebar-link">进程间通信 - JoinableQueue 队列</a></li><li><a href="/kevin-blog/Python/进程间通信 - Manager （了解）.html" class="sidebar-link">进程间通信 - Manager （了解）</a></li><li><a href="/kevin-blog/Python/进程间通信 - Pipe 管道（了解）.html" class="sidebar-link">进程间通信 - Pipe 管道（了解）</a></li><li><a href="/kevin-blog/Python/进程间通信 - Queue 队列.html" class="sidebar-link">进程间通信 - Queue 队列</a></li><li><a href="/kevin-blog/Python/迭代器.html" class="sidebar-link">迭代器</a></li><li><a href="/kevin-blog/Python/递归函数.html" class="sidebar-link">递归函数</a></li><li><a href="/kevin-blog/Python/闭包.html" class="sidebar-link">闭包</a></li><li><a href="/kevin-blog/Python/面向对象.html" class="sidebar-link">面向对象</a></li><li><a href="/kevin-blog/Python/面向对象-内置的类方法.html" class="sidebar-link">面向对象-内置的类方法</a></li><li><a href="/kevin-blog/Python/面向对象-单例模式.html" class="sidebar-link">面向对象-单例模式</a></li><li><a href="/kevin-blog/Python/面向对象-多态.html" class="sidebar-link">面向对象-多态</a></li><li><a href="/kevin-blog/Python/面向对象-封装.html" class="sidebar-link">面向对象-封装</a></li><li><a href="/kevin-blog/Python/面向对象-接口类抽象类.html" class="sidebar-link">面向对象-接口类抽象类</a></li><li><a href="/kevin-blog/Python/面向对象-私有属性方法静态属性.html" class="sidebar-link">面向对象-私有属性方法静态属性</a></li><li><a href="/kevin-blog/Python/面向对象-类执行顺序.html" class="sidebar-link">面向对象-类执行顺序</a></li><li><a href="/kevin-blog/Python/面向对象-继承.html" class="sidebar-link">面向对象-继承</a></li><li><a href="/kevin-blog/Python/面向对象-装饰器.html" class="sidebar-link">面向对象-装饰器</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><div><span><div><div><div><div><div><div><div><div><div><div><div><div><div><span style="font-size:14pt;">socket = 套接字</span></div><div><span style="font-size:14pt;"><br></span></div><div><span style="font-size:14pt;">socket: 实现软件或程序之间的通信</span></div><div><span style="font-size:14pt;"><br></span></div><div><span style="font-size:14pt;"><span style="font-size:14pt;color:rgb(227, 0, 0);">在进行网络传输或通信的时候只能传递通过字符串转码后的bytes类型，然后再对bytes类型进行解码获取传递的数据</span></span></div><div><font style="font-size:14pt;"><br></font></div><div><span style="font-size:14pt;white-space:pre-wrap;font-weight:bold;line-height:1.75;">1.</span><span style="font-weight:bold;"></span><span style="font-size:14pt;font-weight:bold;">socket层</span></div><div><br></div><div><img data-filename="827651-20180107205809034-380661986.png" src="/kevin-blog/Python/socket 模块_files/827651-20180107205809034-380661986.png" type="image/png"></div><div><br></div><div><span style="font-size:14pt;white-space:pre-wrap;font-weight:bold;line-height:1.75;">2.</span><span style="font-weight:bold;"></span><span style="font-size:14pt;font-weight:bold;">套接字的两个种族</span></div><div><span style="font-size:14pt;"><br></span></div><ul><li><div><span style="font-size:12pt;">基于文件类型的套接字家族 -&gt; 现在几乎不用</span></div></li><ul><li><div>套接字家族的名称: <span style="color:rgb(255, 0, 0);">AF_UNX</span></div></li><li><div>UNX一切皆文件，以文件作为介质进行传输</div></li></ul></ul><div><br></div><ul><li><div>基于网络类型的套接字家族 -&gt; 现在常用</div></li><ul><li><div>套接字家族的名称: <span style="color:rgb(255, 0, 0);">AF_INET</span></div></li><li><div>AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET</div></li></ul></ul><div><span style="font-size:14pt;"><br></span></div><div><span style="font-size:14pt;white-space:pre-wrap;font-weight:bold;line-height:1.75;">3.</span><span style="font-weight:bold;"></span><span style="font-size:14pt;font-weight:bold;">基于TCP协议的socket</span></div></div><div><br></div><div><img data-filename="827651-20171027102242789-2142796571.jpg" src="/kevin-blog/Python/socket 模块_files/827651-20171027102242789-2142796571.jpg" type="image/jpeg"></div><div><br></div><ul><li><div><span style="color:rgb(255, 0, 0);">先启动服务端文件再启动客户端文件</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(255, 0, 0);">客户端文件无需执行 conn, addr = sk.accept() 直接使用 sk 对象进行消息的收发</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">有收必有发，收发必相等 -&gt; 如果客户端执行了 send 服务端必须也执行 recv 反之，因为如果客户端或服务端的 conn.recv(1024) 没有接收到消息就会进行阻塞(阻塞: 一直等待，无法运行下面的代码，直到接收到消息)</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">sk.listen(num) -&gt; 监听链接，如果listen传入一个数值，那么就代表只允许多少个客户端进行连接，如果不传则就没有限制，python3.2一下的一定要传</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">recv(num) 只会接受num个字节内的内容，但是num最好不要超过4096</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">不支持多个客户端和服务端进行同时通讯</span></div></li></ul><div><br></div><ul><li><div>在 Pycharm 下切换文件查看打印内容</div></li></ul><div><br></div><div><img data-filename="Image.png" src="/kevin-blog/Python/socket 模块_files/Image.png" type="image/png"></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py 服务端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()  # <font color="#41AD1C">创建socket</font> -&gt; 买手机</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # <font color="#41AD1C">避免服务器重启时报address already in use, 因为服务重启的时候电脑不会立刻关闭端口，而是过一会才关闭，此时端口就会被占用，也有可能是超过了网络最大链接数</font></div><div># sk.bind(('ip地址', 端口))</div><div>sk.bind(('127.0.0.1', 8080))  # <font color="#41AD1C">把地址绑定到socket，传入的值必须是元组</font> -&gt; 绑定手机卡</div><div>sk.listen()  # <font color="#41AD1C">TCP开始<font>监听链接</font></font><font style="color:rgb(65, 173, 28);">，如果listen传入一个数值，那么就代表只允许多少个客户端进行连接，如果不传则就没有限制，python3.2一下的一定要传</font> -&gt; 开始监听有没有人给你打电话</div><div>conn, addr = sk.accept()  # <font color="#41AD1C">等待</font><font color="#41AD1C">接收客户端的链接 返回值: 链接, 地址</font> -&gt; 等待别人给你打电话，并且接听别人的电话</div><div><br></div><div># ——————————————————————————————————</div><div><br></div><div>ret = conn.recv(1024)  # <font color="#41AD1C">接收客户端发送过来的消息（返回值: bytes类型），</font><font color="#E30000"><b>如果没有接收到就会进行阻塞（阻塞: 一直等待，无法运行下面的代码，直到接收到消息）</b></font><font color="#41AD1C">，</font><font color="#E30000"><b>只会接收1024个字节内的内容，如果超过了1024个字节那么再次 conn.recv 就可以获取多余的内容</b></font> -&gt; 听别人说话</div><div>print(ret.decode('utf-8'))  # 打印客户端发送过来的消息</div><div>conn.send(bytes('客户端，你好', encoding='utf-8'))  # <font color="#41AD1C">向客户端发送消息（发送的消息必须是bytes类型）</font>-&gt; 和别人说话</div><div>ret = conn.recv(1024).decode('utf-8')  # <font color="#E30000">可以在 recv 后面直接进行解码</font> -&gt; 听别人说话</div><div>print(ret)  # 打印客户端发送过来的消息</div><div><br></div><div># ——————————————————————————————————</div><div><br></div><div>conn.close()  # <font color="#41AD1C">关闭客户端的socket</font> -&gt; 挂电话</div><div>sk.close()  # <font color="#41AD1C">关闭服务器的socket(可选)</font> -&gt; 关手机</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()  # <font color="#41AD1C">创建客户端socket</font> -&gt; 买手机</div><div>sk.connect(('127.0.0.1', 8080))  # <font color="#41AD1C">尝试链接服务端，传入的值必须是元组</font> -&gt; 拨打别人的电话</div><div><br></div><div># ——————————————————————————————————</div><div><br></div><div>sk.send(bytes('服务端，你好', encoding='utf-8'))  # <font color="#41AD1C">向客户端发送消息</font> -&gt; 和别人说话</div><div>ret = sk.recv(1024).decode('utf-8')  # <font color="#41AD1C">接收服务端发送过来的消息（返回值: bytes类型）</font>，<b><font color="#E30000">如果没有接收到就会进行阻塞（阻塞: 一直等待，无法运行下面的代码，直到接收到消息）</font></b><font color="#41AD1C">，</font><font color="#E30000">只会接收1024个字节内的内容，如果超过了1024个字节那么再次 conn.recv 就可以获取多余的内容，可以在 recv 后面直接进行解码</font> -&gt; 听别人说话</div><div>print(ret)  # 打印服务端发送过来的消息</div><div>sk.send(bytes('服务端，再见', encoding='utf-8'))  # <font color="#41AD1C">向客户端发送消息</font> -&gt; 和别人说话</div><div><br></div><div># ——————————————————————————————————</div><div><br></div><div>sk.close()  # <font color="#41AD1C">关闭客户端的stroke</font> -&gt; 挂电话</div></div><div><br></div></div><ul><li><div>小型的聊天功能</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py 服务端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    ret = conn.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>    if ret == '再见':</div><div>        conn.send(bytes('再见', encoding='utf-8'))</div><div>        break</div><div>    info = input('请输入要向客户端发送的内容：')</div><div>    conn.send(bytes(info, encoding='utf-8'))</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>while True:</div><div>    info = input('请输入要向服务端发送的内容：')</div><div>    sk.send(bytes(info, encoding='utf-8'))</div><div>    ret = sk.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>    if ret == '再见':</div><div>        sk.send(bytes('再见', encoding='utf-8'))</div><div>        break</div><div><br></div><div>sk.close()</div></div><div><br></div></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">如果客户端1向服务端发送了一条消息，然后客户端2也向服务端发送了一条消息，那么服务端只会收到客户端1的消息并且与客户端1进行通信，只有当客户端1结束了通信服务端才能收到客户端2的消息并且与客户端2进行通讯，以此类推，因为当</span><span style="color:rgb(227, 0, 0);font-weight:bold;">服务端与客户端进行了链接通信，如果另一台客户端也想与服务端链接通信，那么要将之前的客户端结束通讯后才能与服务端进行链接通信 -&gt;</span> <span style="color:rgb(227, 0, 0);font-weight:bold;">通俗理解不支持多个客户端和服务端进行同时通讯</span></div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py -&gt; 代码没有进行优化，只是为了方便理解</div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div><br></div><div># ————————————— 第一台客户端执行的通信代码 ———————————————</div><div><br></div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    ret = conn.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>    if ret == '再见':</div><div>        conn.send(bytes('再见', encoding='utf-8'))</div><div>        break</div><div>    info = input('请输入要向客户端发送的内容：')</div><div>    conn.send(bytes(info, encoding='utf-8'))</div><div><br></div><div>conn.close()</div><div><br></div><div># ————————————— 第二台客户端执行的通信代码 -&gt; 和上面代码一样 ———————————————</div><div><br></div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    ret = conn.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>    if ret == '再见':</div><div>        conn.send(bytes('再见', encoding='utf-8'))</div><div>        break</div><div>    info = input('请输入要向客户端发送的内容：')</div><div>    conn.send(bytes(info, encoding='utf-8'))</div><div><br></div><div>conn.close()</div><div><br></div><div>sk.close()  <font color="#E30000"># 如果服务端socket没有关闭，客户端就可以与服务端继续建立链接（通俗理解：就是可以继续执行 conn, addr = sk.accept() 代码）</font></div></div><div><br></div></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py -&gt; 优化后代码</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div><br></div><div># ————————————————————————————</div><div><br></div><div>while True:</div><div>    conn, addr = sk.accept()</div><div><br></div><div>    while True:</div><div>        ret = conn.recv(1024).decode('utf-8')</div><div>        print(ret)</div><div>        if ret == '再见':</div><div>            conn.send(bytes('再见', encoding='utf-8'))</div><div>            break</div><div>        info = input('请输入要向客户端发送的内容：')</div><div>        conn.send(bytes(info, encoding='utf-8'))</div><div><br></div><div>    conn.close()</div><div><br></div><div>sk.close()  # 如果服务端socket没有关闭，客户端就可以与服务端继续建立链接（通俗理解：就是可以继续执行 conn, addr = sk.accept() 代码）</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client1.py 客户端1</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>while True:</div><div>    info = input('请输入要向服务端发送的内容：')</div><div>    sk.send(bytes('客户端1：' + info, encoding='utf-8'))</div><div>    ret = sk.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>    if ret == '再见':</div><div>        sk.send(bytes('再见', encoding='utf-8'))</div><div>        break</div><div><br></div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client2.py 客户端2</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>while True:</div><div>    info = input('请输入要向服务端发送的内容：')</div><div>    sk.send(bytes('客户端2：' + info, encoding='utf-8'))</div><div>    ret = sk.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>    if ret == '再见':</div><div>        sk.send(bytes('再见', encoding='utf-8'))</div><div>        break</div><div><br></div><div>sk.close()</div></div><div><br></div><div><span style="font-size:14pt;white-space:pre-wrap;font-weight:bold;line-height:1.75;">4.</span><span style="font-weight:bold;"></span><span style="font-size:14pt;font-weight:bold;">基于UDP协议的socket</span></div><div><br></div><div><img data-filename="827651-20171027102242789-2142796572.jpg" src="/kevin-blog/Python/socket 模块_files/827651-20171027102242789-2142796572.jpg" type="image/jpeg"></div><div><br></div><ul><li><div><span style="color:rgb(255, 0, 0);">先启动服务端文件再启动客户端文件</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">在使用 sk.sendto('byte类型的消息',('接收消息方的ip',接收消息方的端口)) 一定要传地址元组，一般地址元组都是使用从 recvfrom 返回的地址，或者客户端第一次向服务端发送消息时自己写的服务端的地址元组</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">有收必有发，收发必相等 -&gt; 如果客户端执行了 sendto 服务端必须也执行 recvfrom 反之，因为如果客户端或服务端的 sk.</span><span style="color:rgb(227, 0, 0);font-weight:bold;">recvfrom</span><span style="color:rgb(227, 0, 0);font-weight:bold;">(1024) 没有接收到消息就会进行阻塞(阻塞: 一直等待，无法运行下面的代码，直到接收到消息)</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">recvfrom(num) 只会接受num个字节内的内容，但是num最好不要超过4096</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">支持多个客户端和服务端进行同时通讯</span></div></li></ul><div><br></div><ul><li><div>在 Pycharm 下切换文件查看打印内容</div></li></ul><div><img data-filename="Image.png" src="/kevin-blog/Python/socket 模块_files/Image [1].png" type="image/png"></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py 服务端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div><br></div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div><br></div><div>sk.bind(('127.0.0.1', 8080))</div><div><br></div><div># ————————————————————————————————————</div><div><br></div><div>msg, addr = sk.recvfrom(1024)  <font color="#41AD1C"># 接收客户端发送过来的消息 返回值: 元组 ('bytes类型的消息', 发送消息方的地址元组) -&gt; (b'\xe5\xae\……', ('127.0.0.1', 59608))</font></div><div><br></div><div>print(addr)</div><div>print(msg.decode('utf-8'))</div><div><br></div><div>sk.sendto(bytes('服务端发送给客户端的消息', encoding='utf-8'), addr)  <font color="#41AD1C"># 向客户端发送消息，参数: bytes类型的消息, 接收消息方的地址元组 -&gt; 一般使用 sk.recvfrom(1024) 的返回值 addr 就可以，因为 addr 就是接收消息方的地址元组</font></div><div><br></div><div>msg, add = sk.recvfrom(1024)  <font color="#41AD1C"># 接收客户端发送过来的消息 返回值: 元组 ('bytes类型的消息', 发送消息方的地址元组) -&gt; (b'\xe5\xae\……', ('127.0.0.1', 59608))</font></div><div><br></div><div>print(addr)</div><div>print(msg.decode('utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div><br></div><div>ip_port = ('127.0.0.1', 8080)</div><div><br></div><div># ————————————————————————————————————</div><div><br></div><div>sk.sendto(bytes('客户端发送给服务端的消息1', encoding='utf-8'), ip_port)  <font color="#41AD1C"># 向服务端发送消息，参数: bytes类型的消息, 接收消息方的地址元组 -&gt; 第一次发送一般都是向服务端发送，所以接收消息方的地址元组都要自己写的</font></div><div><br></div><div>msg, addr = sk.recvfrom(1024) <font color="#41AD1C"> # 接收客户端发送过来的消息 返回值: 元组 ('bytes类型的消息',发送方消息方的地址元组) -&gt; (b'\xe5\xae\……', ('127.0.0.1', 8080))</font></div><div><br></div><div>print(addr)</div><div>print(msg.decode('utf-8'))</div><div><br></div><div>sk.sendto(bytes('客户端发送给服务端的消息2', encoding='utf-8'), addr) <font color="#41AD1C"> # 向服务端发送消息，参数: bytes类型的消息, 接收消息方的地址元组 -&gt; 这一次的地址元组可以使用 sk.recvfrom(1024) 的返回值 addr</font></div><div><font color="#41AD1C"><br></font></div><div>sk.close()</div></div><div><br></div><ul><li><div>仿qq通信</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py 服务端</div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div><br></div><div>while True:</div><div>    msg, addr = sk.recvfrom(1024)</div><div>    print(addr)</div><div>    print(msg.decode('utf-8'))</div><div>    info = input('&gt;&gt;&gt;')</div><div>    sk.sendto(bytes(info, encoding='utf-8'), addr)</div><div><br></div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client1.py 客户端1</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>ip_port = ('127.0.0.1', 8080)</div><div><br></div><div>while True:</div><div>    info = input('客户端1：')</div><div>    sk.sendto(bytes('\033[34m来自客户端1的消息:%s\33[0m' % info, encoding='utf-8'), ip_port)</div><div>    msg, addr = sk.recvfrom(1024)</div><div>    print(addr)</div><div>    print(msg.decode('utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client2.py 客户端2</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>ip_port = ('127.0.0.1', 8080)</div><div><br></div><div>while True:</div><div>    info = input('客户端2：')</div><div>    sk.sendto(bytes('\033[32m来自客户端2的消息:%s\33[0m' % info, encoding='utf-8'), ip_port)</div><div>    msg, addr = sk.recvfrom(1024)</div><div>    print(addr)</div><div>    print(msg.decode('utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><ul><li><div>服务端接收从客户端发送过来的时间格式，然后服务端按照时间格式发送一个时间个客户端</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py 服务端</div><div><br></div><div>import socket</div><div>import time</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>while True:</div><div>    time_format, addr = sk.recvfrom(1024)</div><div>    t = time_format.decode('utf-8')</div><div>    sk.sendto(bytes(time.strftime(t), encoding='utf-8'), addr)</div><div><br></div><div>sk.close()</div></div><div><br></div></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>ip_port = ('127.0.0.1', 8080)</div><div>while True:</div><div>    time_format = input('请输入时间格式：')</div><div>    sk.sendto(time_format.encode('utf-8'), ip_port)</div><div>    t, addr = sk.recvfrom(1024)</div><div>    print(t.decode('utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><div><span style="font-size:14pt;white-space:pre-wrap;color:rgb(227, 0, 0);font-weight:bold;line-height:1.75;">5.</span><span style="color:rgb(227, 0, 0);font-weight:bold;"></span><span style="font-size:18.6667px;color:rgb(227, 0, 0);font-weight:bold;">如果客户端断开了链接且服务端还在继续接收客户端的信息，那么接收到的是空信息，不会报错的</span></div><div><span style="font-size:18.6667px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    msg = conn.recv(1024).decode('utf-8')</div><div>    print(msg)</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>sk.send(b'hello')</div><div><br></div><div>sk.close()</div></div><div><br></div><div><span style="font-size:14pt;white-space:pre-wrap;color:rgb(227, 0, 0);font-weight:bold;line-height:1.75;">6.</span><span style="color:rgb(227, 0, 0);font-weight:bold;"><span style="font-size:18.6667px;color:rgb(227, 0, 0);font-weight:bold;">黏包</span></span></div><div><font style="font-size:12pt;"><br></font></div><ul><li><div><span style="font-size:12pt;">只有TCP协议有黏包现象，UDP协议永远不会黏包，但是UDP协议过消息或数据过长，那么他会丢弃过长的那部分或报错</span></div></li></ul><div><span style="font-size:18.6667px;"><br></span></div><ul><li><div><span style="font-size:12pt;">黏包现象:</span></div></li></ul><ol><li><div><span style="font-size:12pt;">如果发送的消息过大接收端得到的结果很有可能是一部分，接收端再执行接收消息的时候又会先接收到之前剩余的部分再接收新消息 -&gt; </span>客户端向服务端发送一段很大的数据，如果接收端的recv(num)中的num的值小于发送过来的数据的字节数的话，那么接收端就会从缓存区中取只在num个字节内的值，如果服务端再次接受数据的时候就会从缓存取中先获取上次没有接收完的数据，然后再取新数据</div></li><li><div>同时执行 sk.send(b'hello') 和 sk.send(b'world') 所收到的结果是 helloworld，因为两次发送的消息过小且时间间隔短，那么就会将两次消息合并在一起发送</div></li></ol><div><br></div><ul><li><div>黏包成因:</div></li><ul><li><div>黏包现象1的解释：因为TCP协议中有拆包机制 -&gt; 如果本机的MTU（网络发送的最大数据包）大于网关的MTU，那么大的数据包最会被拆开来传递 -&gt; 通俗理解: 如果发送的消息或数据过大TCP就会拆开传递</div></li><li><div>黏包现象2的解释：因为在TCP协议中使用了优化算法（Nagle算法），它会将多次时间间隔较小且数据量小的数据，合并成一个大的数据块来进行传递</div></li></ul></ul><div><br></div><div><img data-filename="827651-20180107213012565-1511102109.png" src="/kevin-blog/Python/socket 模块_files/827651-20180107213012565-1511102109.png" type="image/png"></div><div><br></div><ul><ul><li><div>recv(num)一旦被调用，就会尝试获取缓冲区中的数据，只要有数据，就会直接返回，如果 num 为1024那么就会从缓存区中取1024字节的数据，如果缓存区只有400字节的数据，那么也只会取400字节的数据，而多出来的数据只能在下次 recv(num) 是获取</div></li><li><div>通俗理解: 同时执行多个 send() 的时候，且 send() 之间没有执行recv() 就会有可能出现黏包现象</div></li><li><div>总结: 主要还是因为接收端不知道一次要 recv(num) 多少个字节所构成的，如果每次执行 recv(num) 的时候都知道准确的消息字节数的话就不会发生黏包问题了，不连续 send() 的，且send()的后面跟着 recv(num) 也不会出现黏包问题</div></li></ul></ul><div><br></div><ul><li><div>TCP协议的黏包现象1:</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py 服务端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>msg = conn.recv(2)  # 限制了只获取2个字节的内容</div><div>print(msg.decode('utf-8'))  # he 因为消息过长只会获取到一部分</div><div>msg = conn.recv(10)  # 限制了只获取10个字节的内容</div><div>print(msg.decode('utf-8'))  # llo-Kevin 获取上次没有获取到的部分</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>sk.send(bytes('hello-Kevin', encoding='utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><ul><li><div>TCP协议的黏包现象2:</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"># server.py 服务端</span></div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>msg1 = conn.recv(1024)</div><div>print(msg1)  # b'helloworld'</div><div>msg1 = conn.recv(1024)</div><div>print(msg1)  # b'' -&gt; 当发送端关闭 socket 的时候就会发送一个空的值过来</div><div>msg1 = conn.recv(1024)</div><div>print(msg1)  # b''</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>sk.send(b'hello')</div><div>sk.send(b'world')</div><div><br></div><div>sk.close()</div></div><div><br></div><ul><li><div>基于TCP实现黏包例子: 远程执行命令 -&gt; 在server端发送命令行命令给client端执行并且把执行结果返回个服务端 -&gt; subprocess模块，执行系统命令会分别返回执行成功和失败的结果</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    cmd = input('请输入正确或者错误的系统命令：')</div><div>    conn.send(cmd.encode('utf-8'))</div><div>    ret = conn.recv(1024).decode('utf-8')</div><div>    print(ret)</div><div>conn.close()</div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div>import subprocess</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div>while True:</div><div>    cmd = sk.recv(1024).decode('utf-8')</div><div>    ret = subprocess.Popen(</div><div>        cmd,</div><div>        shell=True,</div><div>        stdout=subprocess.PIPE,</div><div>        stderr=subprocess.PIPE</div><div>    )</div><div>    stdout = '执行成功的返回值:' + (ret.stdout.read()).decode('gbk')</div><div>    stderr = '执行失败的返回值:' + (ret.stderr.read()).decode('gbk')</div><div>    print(stdout)</div><div>    print(stderr)</div><div>    sk.send(stdout.encode('utf-8'))</div><div>    sk.send(stderr.encode('utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><ul><li><div><span style="font-size:12pt;">UDP协议永远不会黏包，但是UDP协议过消息或数据过长，那么他会丢弃过长的那部分，如果接受到的消息字节数大于 </span>recvfrom() 所设置的数就会报错</div></li></ul><div><br></div><ul><ul><li><div>基于UDP实现丢弃过长部分: 远程执行命令 -&gt; 在server端发送命令行命令给client端执行并且把执行结果返回个服务端 -&gt; subprocess模块，执行系统命令会分别返回执行成功和失败的结果</div></li></ul></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"># server.py</span></div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>msg, addr = sk.recvfrom(1024)</div><div><br></div><div>while True:</div><div>    cmd = input('请输入正确或者错误的系统命令：')  # 输入循序 ls -&gt; ipconfig -&gt; dir</div><div>    sk.sendto(cmd.encode('utf-8'), addr)</div><div>    msg, addr = sk.recvfrom(10240)</div><div>    print(msg.decode('utf-8'))</div><div><br></div><div>sk.close()</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div>import subprocess</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>ip_sort = ('127.0.0.1', 8080)</div><div>sk.sendto(bytes('为了服务端能获取到客户端的地址才发此条消息', encoding='utf-8'), ip_sort)</div><div><br></div><div>while True:</div><div>    cmd, addr = sk.recvfrom(1024)</div><div>    ret = subprocess.Popen(</div><div>        cmd.decode('utf-8'),</div><div>        shell=True,</div><div>        stdout=subprocess.PIPE,</div><div>        stderr=subprocess.PIPE</div><div>    )</div><div>    stdout = '执行成功的返回值:' + (ret.stdout.read()).decode('gbk')</div><div>    stderr = '执行失败的返回值:' + (ret.stderr.read()).decode('gbk')</div><div>    print(stdout)</div><div>    print(stderr)</div><div>    sk.sendto(stdout.encode('utf-8'), addr)</div><div>    sk.sendto(stderr.encode('utf-8'), addr)</div><div><br></div><div>sk.close()</div></div><div><br></div><ul><ul><li><div>报错现象 -&gt; 解决方法:接收端的 recvfrom 的值设置大于接收到消息的字节数</div></li></ul></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"># server.py 服务端</span></div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div><br></div><div>msg, addr = sk.recvfrom(1024)</div><div>print(msg.decode('utf-8'))  # 报错</div><div><br></div><div>msg, addr = sk.recvfrom(1024)</div><div>print(msg.decode('utf-8'))</div></div><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py 客户端</div><div><br></div><div>import socket</div><div><br></div><div>s1 = r''' 驱动器 C 中的卷没有标签。</div><div>卷的序列号是 000B-A3DF</div><div><br></div><div>C:\Users\KX201711 的目录</div><div><br></div><div>2019/02/12  08:27    &lt;DIR&gt;          .</div><div>2019/02/12  08:27    &lt;DIR&gt;          ..</div><div>2019/01/23  16:58    &lt;DIR&gt;          .android</div><div>2018/10/13  14:55    &lt;DIR&gt;          .AndroidStudio2.3</div><div>2018/10/15  10:43    &lt;DIR&gt;          .AndroidStudio3.2</div><div>2018/06/22  16:00    &lt;DIR&gt;          .atom</div><div>2018/10/22  16:46         7,430,209 .babel.json</div><div>2019/01/14  15:13             8,979 .bash_history</div><div>2019/02/15  08:34    &lt;DIR&gt;          .BigNox</div><div>2017/11/13  08:24    &lt;DIR&gt;          .config</div><div>2018/08/03  16:59                37 .dbshell</div><div>2018/10/16  09:52    &lt;DIR&gt;          .electron</div><div>2018/10/15  15:50                16 .emulator_console_auth_token</div><div>2018/10/15  14:44    &lt;DIR&gt;          .expo</div><div>2017/11/18  13:41    &lt;DIR&gt;          .gem</div><div>2017/11/18  14:16               121 .gemrc</div><div>2018/08/20  08:31               174 .gitconfig</div><div>2018/10/13  16:44    &lt;DIR&gt;          .gradle</div><div>2018/07/10  08:12                42 .minttyrc</div><div>2018/08/03  09:25                 0 .mongorc.js</div><div>2018/03/17  10:33             9,350 .v8flags.6.2.414.50.dba84d59341dcb557c327ad510bd5ce2.json</div><div>2019/01/07  13:56            11,876 .viminfo</div><div>2018/01/19  16:00    &lt;DIR&gt;          新建文件夹</div><div>              21 个文件    846,679,223 字节</div><div>              50 个目录 28,960,673,792 可用字节'''</div><div><br></div><div>s2 = r'''</div><div>Windows IP 配置</div><div><br></div><div><br></div><div>以太网适配器 以太网:</div><div><br></div><div>   连接特定的 DNS 后缀 . . . . . . . : www.tendawifi.com</div><div>   本地链接 IPv6 地址. . . . . . . . : fe80::295f:b971:88c8:f39d%11</div><div>   IPv4 地址 . . . . . . . . . . . . : 192.168.0.138</div><div>   子网掩码  . . . . . . . . . . . . : 255.255.255.0</div><div>   默认网关. . . . . . . . . . . . . : 192.168.0.1</div><div><br></div><div>以太网适配器 VirtualBox Host-Only Network:</div><div><br></div><div>   连接特定的 DNS 后缀 . . . . . . . :</div><div>   本地链接 IPv6 地址. . . . . . . . : fe80::d10d:58d8:d36e:107f%6</div><div>   IPv4 地址 . . . . . . . . . . . . : 192.168.56.1</div><div>   子网掩码  . . . . . . . . . . . . : 255.255.255.0</div><div>   默认网关. . . . . . . . . . . . . :</div><div><br></div><div>以太网适配器 VirtualBox Host-Only Network #2:</div><div><br></div><div>   连接特定的 DNS 后缀 . . . . . . . :</div><div>   本地链接 IPv6 地址. . . . . . . . : fe80::e8:372e:bf52:6d95%5</div><div>   IPv4 地址 . . . . . . . . . . . . : 192.168.224.2</div><div>   子网掩码  . . . . . . . . . . . . : 255.255.255.0</div><div>   默认网关. . . . . . . . . . . . . :'''</div><div><br></div><div>sk = socket.socket(type=socket.SOCK_DGRAM)</div><div>ip_port = ('127.0.0.1', 8080)</div><div>sk.sendto(bytes(s1, encoding='utf-8'), ip_port)</div><div>sk.sendto(bytes(s2, encoding='utf-8'), ip_port)</div></div><div><br></div></div><div><span style="font-size:14pt;white-space:pre-wrap;color:rgb(227, 0, 0);font-weight:bold;line-height:1.75;">7.</span><span style="color:rgb(227, 0, 0);font-weight:bold;"></span><span style="font-size:18.6667px;color:rgb(227, 0, 0);font-weight:bold;">黏包的解决方案一</span></div><div><span style="font-size:18.6667px;"><br></span></div><ul><li><div><span style="font-size:12pt;">问题的根源在于，接收端不知道发送端将要传送数据的字节长度，所以解决黏包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的</span><span style="font-size:12pt;">总</span><span style="font-size:12pt;">字节大小让接收端知晓，然后接收端通过总字节数限制一次接受多少数据</span></div></li></ul><div><br></div><ul><li><div><span style="color:rgb(227, 0, 0);font-weight:bold;">注意要以bytes类型去计算所要发送消息的字节长度，因为 recv 是按字节长度去获取的</span></div></li></ul><div><br></div><div><img data-filename="827651-20180107211210612-35513522.png" src="/kevin-blog/Python/socket 模块_files/827651-20180107211210612-35513522.png" type="image/png"></div><div><br></div><ul><li><div>使用这种方式所存在的问题就是多了一次 send 和 recv 的交互</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># 解决远程执行命令例子中的黏包问题</div><div><br></div><div># server.py</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8081))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    cmd = input('请输入正确或者错误的系统命令：')</div><div>    conn.send(cmd.encode('utf-8'))</div><div>    num = conn.recv(1024).decode('utf-8')<font color="#E30000">  # 接收内容的总字节数</font></div><div>    conn.send(b'ok')<font color="#E30000">  # 发送确认消息</font></div><div>    ret = conn.recv(int(num)).decode('gbk')<font color="#E30000">  # 通过总字节数设置可以接受多少数据，比如接收到的消息的总字节数为5，那么 recv 只会接收5个字节数的消息，这样就不会发生黏包问题</font></div><div>    print(ret)</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><span style="font-size:14pt;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div>import subprocess</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8081))</div><div><br></div><div>while True:</div><div>    cmd = sk.recv(1024).decode('utf-8')</div><div>    ret = subprocess.Popen(</div><div>        cmd,</div><div>        shell=True,</div><div>        stdout=subprocess.PIPE,</div><div>        stderr=subprocess.PIPE</div><div>    )</div><div>    stdout = ret.stdout.read()</div><div>    stderr = ret.stderr.read()</div><div>    sk.send(str(len(stdout) + len(stderr)).encode('utf-8'))  <font><font color="#E30000"># 将内容的总字节数首先发送给服务端 -&gt;</font> <b><font color="#AD0000" style="font-size:11pt;">注意要以bytes类型去计算所要发送消息的字节长度，因为 recv 是按字节长度去获取的</font></b></font></div><div>    sk.recv(1024) <font color="#E30000"> # 接收确认消息，如果没有接收此消息，那么在这里就会发生黏包问题</font></div><div>    sk.send(stdout)</div><div>    sk.send(stderr)</div><div><br></div><div>sk.close()</div></div><div><span style="font-size:14pt;"><br></span></div><div><span style="box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;font-size:14pt;white-space:pre-wrap;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;line-height:1.75;">8.</span><span style="box-sizing:border-box;font-size:medium;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;"></span><span style="box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;font-size:18.6667px;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;">黏包的解决方案二</span></div></div><div><span style="box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;font-size:18.6667px;"><br></span></div><ul><li><div><span style="font-size:12pt;">使用struct模块将要发送的内容的总字节数转换为固定的bytes类型传给接收端，然后接受端以固定的字节数接收该bytes类型，这样就算发送端连续执行send()发送数据出现了黏包问题，客户端也可以通过</span><span style="font-size:12pt;">固定的字节数接收到该数据，这样也解决了黏包解决方案一中</span>多了一次 send 和 recv 的交互的问题</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># 解决远程执行命令例子中的黏包问题</div><div><br></div><div># server.py</div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div>import struct</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8081))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>while True:</div><div>    cmd = input('请输入正确或者错误的系统命令：')</div><div>    conn.send(cmd.encode('utf-8'))</div><div>    num = conn.recv(4)  <font color="#FF0000"># b'A\x00\x00\x00' 接收固定长度的bytes类型的内容总字节数 -&gt; 以4个字节去读取内容总字节数，因为int类型通过struct模块转化后得到的bytes类型的长度是4</font></div><div>    num = struct.unpack('i', num)[0] <font color="#FF0000"> # (65,)[0] 对固定长度的bytes类型进行解码，获取到内容总字节数</font></div><div>    ret = conn.recv(int(num)).decode('gbk')  <font style="color:rgb(255, 0, 0);"># 通过总字节数设置可以接受多少数据，比如接收到的消息的总字节数为5，那么 recv 只会接收5个字节数的消息，这样就不会发生黏包问题</font></div><div>    print(ret)</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><br></div></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div>import subprocess</div><div>import struct</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8081))</div><div><br></div><div>while True:</div><div>    cmd = sk.recv(1024).decode('utf-8')</div><div>    ret = subprocess.Popen(</div><div>        cmd,</div><div>        shell=True,</div><div>        stdout=subprocess.PIPE,</div><div>        stderr=subprocess.PIPE</div><div>    )</div><div>    stdout = ret.stdout.read()</div><div>    stderr = ret.stderr.read()</div><div>    len_num = len(stdout) + len(stderr)</div><div>    bytes_num = struct.pack('i', len_num)<font color="#FF0000">  # b'A\x00\x00\x00' 将内容总字节数转化为固定长度的bytes类型</font></div><div>    sk.send(bytes_num)<font color="#FF0000">  # 发送固定长度的bytes类型给服务端</font></div><div>    sk.send(stdout)</div><div>    sk.send(stderr)</div><div><br></div><div>sk.close()</div></div><div><br></div><div><font style="font-size:14pt;"><span style="box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;white-space:pre-wrap;font-size:14pt;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;line-height:1.75;">9.</span><span style="box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;font-size:14pt;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;"> 报头和报文</span></font></div><div><span style="box-sizing:border-box;font-size:medium;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><ul><li><div><span style="font-size:12pt;">在网络上传输的所有数据都叫数据包</span></div></li><li><div>数据包里面的所有数据都叫报文</div></li><li><div>所有的报文都会有报头 / 所有的协议都会有报头</div></li><li><div>报头，在数据的传输过程中不止只有你的数据，还有ip地址 端口 mac地址……这些就是报头 -&gt; 通俗理解: 除了你要传输的数据之外的消息就叫报头</div></li><li><div><span style="color:rgb(227, 0, 0);">报头的作用: 比如客户端要向服务端发送一个文件且服务端想知道该文件的相关信息，例如：文件的名字/大小/类型，这时候我们就可以定制一个报文发送个服务端 -&gt; 上面提到的解决黏包问题的总字节数一般都会放在报头（字典）中发送给接收端解决黏包问题</span></div></li><li><div><span style="color:rgb(227, 0, 0);">报头也可以理解为发送端最先发送的关于该数据的相关信息的消息，一般都是字典 -&gt; 上面解决黏包方法中先发送一个总字节数的固定长度的bytes类型给服务端，而当中的固定长度的bytes类型就是报头</span></div></li><li><div><span style="color:rgb(227, 0, 0);">报头是最先发送的也是接收端最先接收到的</span></div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py</div><div><br></div><div>import socket</div><div>import struct</div><div>import json</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8081))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>h_fixed_len_bytes = conn.recv(4) <font style="color:rgb(255, 0, 0);"> # 接收固定长度的bytes类型的报头总字节数</font></div><div>h_fixed_len = struct.unpack('i', h_fixed_len_bytes)  <font style="color:rgb(255, 0, 0);"># (76,) 对固定长度的bytes类型进行解码，获取到报头总字节数</font></div><div>h_json = conn.recv(h_fixed_len[0]).decode('utf-8')  <font style="color:rgb(255, 0, 0);"># 通过总字节数设置可以接受多少数据从而获取到字符串类型的报头</font></div><div>header = json.loads(h_json)  <font style="color:rgb(255, 0, 0);"># 将字符串类型的报头装换为Python代码</font></div><div>print(header)  <font color="#41AD1C"># {'msg_len': 24, 'msg_info': '关于msg的相关消息'}</font></div><div>msg_len = int(header['msg_len'])  <font color="#FF0000"># 通过报头获取到要接收的信息的总字节数</font></div><div>msg = conn.recv(msg_len).decode('utf-8')  <font color="#FF0000"># 通过总字节数获取到客户端发送过来的消息</font></div><div>print(msg)  # 服务端接收的消息</div><div><br></div><div>sk.close()</div></div><div><span style="box-sizing:border-box;font-size:medium;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py -&gt; 将要发送的内容的总字节数放在报头中发送给服务端，服务端通过报头中的总字节数接收相关字节数长度的内容</div><div><br></div><div>import socket</div><div>import struct</div><div>import json</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8081))</div><div><br></div><div>msg = bytes('服务端接收的消息', encoding='utf-8')  <font color="#FF0000"># 需要发送给服务端的数据 -&gt; 报文</font></div><div><br></div><div>header = {  <b><font color="#AD0000"># 定制报头</font></b></div><div>    'msg_len': len(msg), <font color="#41AD1C"> # 需要发送给服务端的数据的总字节数</font></div><div>    'msg_info': '关于msg的相关消息'</div><div>}</div><div>h_json = json.dumps(header) <font color="#FF0000"> # 将报头转换为json字符串</font> <font color="#41AD1C">-&gt; {&quot;msg_info&quot;: &quot;\u5173\……&quot;, &quot;msg_len&quot;: 24}</font></div><div>h_bytes = bytes(h_json, encoding='utf-8')  <font color="#FF0000"># 将json字符串转换为bytes类型</font> <font color="#41AD1C">-&gt; b'{&quot;msg_info&quot;: &quot;\\u5173\\……, &quot;msg_len&quot;: 24}'</font></div><div>h_bytes_len = len(h_bytes)  <font color="#FF0000"># 得到报头的总字节数</font> <font color="#41AD1C">-&gt; 76</font></div><div>h_fixed_len_bytes = struct.pack('i', h_bytes_len) <font style="color:rgb(255, 0, 0);"> # 将报头的总字节数转化为固定长度的bytes类型</font> <font color="#41AD1C">-&gt; b'L\x00\x00\x00'</font></div><div><br></div><div>sk.send(h_fixed_len_bytes)  <font style="color:rgb(255, 0, 0);"># 发送固定长度的bytes类型的报头总字节数</font></div><div>sk.send(bytes(h_json, encoding='utf-8'))  <font color="#FF0000"># 发送报头</font></div><div>sk.send(msg)  <font color="#FF0000"># 发送报文</font></div><div><br></div><div>sk.close()</div></div><div><span style="box-sizing:border-box;font-size:medium;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;white-space:pre-wrap;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;line-height:1.75;">10.</span><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;"> 实现大文件的上传或下载 -&gt; 大文件的传输</span></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div><a href="/kevin-blog/Python/socket 模块_files/file_transfer.rar"><img alt="file_transfer.rar" src="/kevin-blog/Python/socket 模块_files/05a0e34f01789af58d65e1463761ea80.png"></a></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py -&gt; 接收端</div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div>import struct</div><div>import json</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8081))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div>buffer = 1024  <font color="#41AD1C"># 每次写入多少字节的数据，这里最好写1024因为数值越大就越容易出错</font></div><div><br></div><div>bytes_header_len = conn.recv(4)  <font color="#41AD1C"># 接收固定长度的bytes类型的报头总字节数</font></div><div>header_len = struct.unpack('i', bytes_header_len)  <font color="#41AD1C"># 对固定长度的bytes类型进行解码，获取到报头总字节数</font></div><div>json_header = conn.recv(header_len[0]).decode('utf-8')  <font color="#41AD1C"># 通过总字节数设置可以接受多少数据从而获取到字符串类型的报头</font></div><div>header = json.loads(json_header)  <font color="#41AD1C"># 将字符串类型的报头装换为Python代码</font></div><div><br></div><div>filesize = header['filesize']  <font color="#41AD1C"># 从报头中获取文件的大小（总字节数）</font></div><div>with open(r'movie\%s' % header['filename'], 'wb') as f:  <font color="#41AD1C"># 以bytes类型的方式写入文件，因为传送过来的数据是bytes类型的 -&gt; 根目录下一定要有movie文件夹</font></div><div>    while filesize:</div><div>        if filesize &gt;= buffer:</div><div>            print(filesize, 1)</div><div>            content = conn.recv(buffer)  <font color="#41AD1C"># 按照固定的字节去接收数据</font></div><div>            f.write(content)  <font color="#41AD1C"># 将数据写入到文件中</font></div><div>            filesize -= buffer  <font color="#41AD1C"># 因为上面已经接收了1024个字节，所以 总节数-buffer = 剩下的未接收的字节数</font></div><div>        else:</div><div>            print(filesize, 2)</div><div>            content = conn.recv(filesize)  <font color="#41AD1C"># 接收最后剩下字节数且该字节数已经小于buffer的数据</font></div><div>            f.write(content)  <font color="#41AD1C"># 将数据写入到文件中</font></div><div>            filesize = 0</div><div>            print(filesize, 3)</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py -&gt; 发送端</div><div><br></div><div>import socket</div><div>import struct</div><div>import json</div><div>import os</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8081))</div><div>buffer = 1024 <font color="#41AD1C"> # 每次发送多少字节的数据，这里最好写1024因为数值越大就越容易出错</font></div><div><br></div><div>header = {  <font color="#41AD1C"># 定制报文 -&gt; 要发送文件的相关信息</font></div><div>    'filepath': r'D:\Movie',</div><div>    'filename': r'Ghost blowing light.mp4'</div><div>}</div><div>file_path = os.path.join(header['filepath'], header['filename'])  <font color="#41AD1C"># 拼接文件夹名和文件名从而获得文件的完整路径</font></div><div>filesize = os.path.getsize(file_path)  <font color="#41AD1C"># 获取文件大小（总字节数）</font></div><div>header['filesize'] = filesize <font color="#41AD1C"> # 将文件大小（总字节数）添加到报头里</font></div><div>json_header = json.dumps(header)  <font color="#41AD1C"># 将报头转为字符串</font></div><div>bytes_header = bytes(json_header, encoding='utf-8') <font color="#41AD1C"> # 将报头转化为bytes类型</font></div><div>header_len = len(bytes_header)  <font color="#41AD1C"># 获取报头的总字节数</font></div><div>bytes_header_len = struct.pack('i', header_len)  <font color="#41AD1C"># 将报头的总字节数转化为固定长度的bytes类型</font></div><div>sk.send(bytes_header_len)  <font color="#41AD1C"># 发送固定长度的bytes类型的报头总字节数</font></div><div>sk.send(bytes_header)  <font color="#41AD1C"># 发送报头</font></div><div><br></div><div>with open(file_path, 'rb') as f: <font color="#41AD1C"> # bytes类型读取文件，因为 sk.send() 就是发送bytes类型的</font></div><div>    while filesize:</div><div>        if filesize &gt;= buffer:</div><div>            print(filesize, 1)</div><div>            content = f.read(buffer)  <font color="#41AD1C"># 按照固定的字节去读取文件</font></div><div>            sk.send(content)  <font color="#41AD1C"># 将读取到的文件发送个服务端</font></div><div>            filesize -= buffer  <font color="#41AD1C"># 因为上面已经读取了1024个字节，所以 总节数-buffer = 剩下的未读的字节数</font></div><div>        else:</div><div>            print(filesize, 2)</div><div>            content = f.read(filesize)  <font color="#41AD1C"># 读取最后剩下字节数且该字节数已经小于buffer的内容</font></div><div>            sk.send(content)  <font color="#41AD1C"># 将读取到的文件发送个服务端</font></div><div>            filesize = 0</div><div>            print(filesize, 3)</div><div><br></div><div>sk.close()</div></div><div><br></div><div><br></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;white-space:pre-wrap;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;line-height:1.75;">11.</span><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;"> 实现大文件的上传或下载后验证文件的一致性（验证两个文件是否一致）</span></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div><a href="/kevin-blog/Python/socket 模块_files/file_consistency.rar"><img alt="file_consistency.rar" src="/kevin-blog/Python/socket 模块_files/9f1bb3f2abdda0100a68c3579d60b9b2.png"></a></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py</div><div><br></div><div>import socket</div><div>import struct</div><div>import json</div><div>import hashlib</div><div><br></div><div>md5 = hashlib.md5()</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8081))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div>buffer = 1024  <font color="#41AD1C"># 每次写入多少字节的数据，这里最好写1024因为数值越大就越容易出错</font></div><div><br></div><div>bytes_header_len = conn.recv(4)  <font color="#41AD1C"># 接收固定长度的bytes类型的报头总字节数</font></div><div>header_len = struct.unpack('i', bytes_header_len)  <font color="#41AD1C"># 对固定长度的bytes类型进行解码，获取到报头总字节数</font></div><div>json_header = conn.recv(header_len[0]).decode('utf-8') <font color="#41AD1C"> # 通过总字节数设置可以接受多少数据从而获取到字符串类型的报头</font></div><div>header = json.loads(json_header)  <font color="#41AD1C"># 将字符串类型的报头装换为Python代码</font></div><div><br></div><div>filesize = header['filesize']  <font color="#41AD1C"># 从报头中获取文件的大小（总字节数）</font></div><div>with open(r'movie\%s' % header['filename'], 'wb') as f:  <font color="#41AD1C"># 以bytes类型的方式写入文件，因为传送过来的数据是bytes类型的 -&gt; 根目录下一定要有movie文件夹</font></div><div>    while filesize:</div><div>        if filesize &gt;= buffer:</div><div>            print(filesize, 1)</div><div>            content = conn.recv(buffer)  <font color="#41AD1C"># 按照固定的字节去接收数据</font></div><div>            md5.update(content)  <font color="#E30000"># 使用多次 update 获取 md5 值</font></div><div>            f.write(content)  <font color="#41AD1C"># 将数据写入到文件中</font></div><div>            filesize -= buffer  <font color="#41AD1C"># 因为上面已经接收了1024个字节，所以 总节数-buffer = 剩下的未接收的字节数</font></div><div>        else:</div><div>            print(filesize, 2)</div><div>            content = conn.recv(filesize)  <font color="#41AD1C"># 接收最后剩下字节数且该字节数已经小于buffer的数据</font></div><div>            md5.update(content) <font color="#E30000"> # 使用多次 update 获取 md5 值</font></div><div>            f.write(content)  <font color="#41AD1C"># 将数据写入到文件中</font></div><div>            filesize = 0</div><div>            print(filesize, 3)</div><div><br></div><div>ciphertext = md5.hexdigest()  <font color="#E30000"># 得到上传完后文件的md5值</font></div><div>print(ciphertext, 1)</div><div><br></div><div>client_ciphertext = conn.recv(1024).decode('utf-8')  <font color="#E30000"># 接收客户端发送过来的原文件的md5值</font></div><div>print(client_ciphertext, 2)</div><div><br></div><div>if ciphertext == client_ciphertext:  <font color="#E30000"># 使用 md5 进行文件的一致性验证</font></div><div>    print('上传完后的文件和原文件一致')</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div>import struct</div><div>import json</div><div>import os</div><div>import hashlib</div><div><br></div><div>md5 = hashlib.md5()</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8081))</div><div>buffer = 1024  <font color="#41AD1C"># 每次发送多少字节的数据，这里最好写1024因为数值越大就越容易出错</font></div><div><br></div><div>header = {  <font color="#41AD1C"># 定制报文 -&gt; 要发送文件的相关信息</font></div><div>    'filepath': r'D:\Movie',</div><div>    'filename': r'Ghost blowing light.mp4'</div><div>}</div><div>file_path = os.path.join(header['filepath'], header['filename'])  <font color="#41AD1C"># 拼接文件夹名和文件名从而获得文件的完整路径</font></div><div>filesize = os.path.getsize(file_path)  <font color="#41AD1C"># 获取文件大小（总字节数）</font></div><div>header['filesize'] = filesize  <font color="#41AD1C"># 将文件大小（总字节数）添加到报头里</font></div><div>json_header = json.dumps(header)  <font color="#41AD1C"># 将报头转为字符串</font></div><div>bytes_header = bytes(json_header, encoding='utf-8') <font color="#41AD1C"> # 将报头转化为bytes类型</font></div><div>header_len = len(bytes_header)  <font color="#41AD1C"># 获取报头的总字节数</font></div><div>bytes_header_len = struct.pack('i', header_len)  <font color="#41AD1C"># 将报头的总字节数转化为固定长度的bytes类型</font></div><div>sk.send(bytes_header_len) <font color="#41AD1C"> # 发送固定长度的bytes类型的报头总字节数</font></div><div>sk.send(bytes_header) <font color="#41AD1C"> # 发送报头</font></div><div><br></div><div>with open(file_path, 'rb') as f: <font color="#41AD1C"> # bytes类型读取文件，因为 sk.send() 就是发送bytes类型的</font></div><div>    while filesize:</div><div>        if filesize &gt;= buffer:</div><div>            print(filesize, 1)</div><div>            content = f.read(buffer)  <font color="#41AD1C"># 按照固定的字节去读取文件</font></div><div>            md5.update(content) <font color="#E30000"> # 使用多次 update 获取 md5 值</font></div><div>            sk.send(content)  <font color="#41AD1C"># 将读取到的文件发送个服务端</font></div><div>            filesize -= buffer  <font color="#41AD1C"># 因为上面已经读取了1024个字节，所以 总节数-buffer = 剩下的未读的字节数</font></div><div>        else:</div><div>            print(filesize, 2)</div><div>            content = f.read(filesize)  <font color="#41AD1C"># 读取最后剩下字节数且该字节数已经小于buffer的内容</font></div><div>            md5.update(content)  <font color="#E30000"># 使用多次 update 获取 md5 值</font></div><div>            sk.send(content)  <font color="#41AD1C"># 将读取到的文件发送个服务端</font></div><div>            filesize = 0</div><div>            print(filesize, 3)</div><div><br></div><div>ciphertext = md5.hexdigest()  <font color="#E30000"># 得到原文件 md5 值</font></div><div>print(ciphertext)</div><div>sk.send(bytes(ciphertext, encoding='utf-8'))  <font color="#E30000"># 将原文件 md5 值发送给服务端进行文件的一致性验证</font></div><div><br></div><div>sk.close()</div></div><div><br></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;white-space:pre-wrap;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;line-height:1.75;">12.</span><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;color:rgb(227, 0, 0);font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;"> 验证客户端的合法性</span></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><ul><li><div><span style="font-size:12pt;">当服务端不想随便被任何一个客户端进行链接，只能通过密钥和服务端发送过来的消息进行加密，然后将加密后的内容发送个服务端进行验证</span></div></li><li><div>使用 hmac加密模块进行加密，也可以使用hashlib加密模块</div></li></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py</div><div><br></div><div>import os</div><div>import hmac</div><div>import socket</div><div><br></div><div>key = '123'  # 密钥/盐</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div><br></div><div>def check_conn(conn):</div><div>    msg = os.urandom(32)  <font color="#41AD1C"># 随机生成长度为32位的bytes类型</font></div><div>    conn.send(msg)  <font color="#41AD1C"># 将随机生成长度为32位的bytes类型发送个客户端，进行和密钥的加密</font></div><div>    h = hmac.new(bytes(key, encoding='utf-8'), msg, digestmod='MD5')  <font color="#41AD1C"># 将密钥和随机生成长度为32位的bytes类型进行md5加密</font></div><div>    digest = h.digest()  <font color="#41AD1C"># 获取加密后的值，以二进制的形式返回，且是bytes类型</font></div><div>    client_digest = conn.recv(1024)  <font color="#41AD1C"># 接收客户端通过密钥加密后的信息</font></div><div>    return hmac.compare_digest(digest, client_digest)  <font color="#41AD1C"># 比较服务端和客户端加密后的信息是否一致</font></div><div><br></div><div>conn, addr = sk.accept()</div><div>res = check_conn(conn)</div><div><br></div><div>if res:</div><div>    print('合法客户端')</div><div>else:</div><div>    print('不合法客户端')</div></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import os</div><div>import hmac</div><div>import socket</div><div><br></div><div>key = '123'  # 密钥/盐</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>msg = sk.recv(1024)  <font color="#41AD1C"># 接收服务端随机生成长度为32位的bytes类型</font></div><div>h = hmac.new(bytes(key, encoding='utf-8'), msg, digestmod='MD5')  <font color="#41AD1C"># 将密钥和服务端发送过来的消息进行加密</font></div><div>digest = h.digest() <font color="#41AD1C"> # 获取加密后的值，以二进制的形式返回，且是bytes类型</font></div><div>sk.send(digest)  <font color="#41AD1C"># 将加密后的值发送给服务端进行验证，判断该客户端是否合法</font></div><div><br></div><div>sk.close()</div></div><div><br></div></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;white-space:pre-wrap;font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;line-height:1.75;">13.</span><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;"></span> <span style="font-size:14pt;"><span style="font-size:14pt;font-weight:bold;">socket</span></span><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;font-family:&quot;Courier New&quot;;font-variant-caps:normal;font-variant-ligatures:normal;font-weight:bold;">的其他方法</span></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><ul><li><div><span style="font-size:12pt;">sk.sendall() -&gt; 将所有数据一次性发送过去，有可能会会出现丢包 -&gt; 还是建议使用 send</span></div></li></ul><div><br></div><ul><ul><li><div><span style="font-size:12pt;">sendall 和 send 的区别就是 send 如果要发送的数据过大就会将数据拆开发送（简称拆包），而sendall则不会</span></div></li></ul></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"># server.py</span></div><div><span style="font-size:9pt;color:rgb(51, 51, 51);font-family:Monaco;"><br></span></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>msg = conn.recv(1024).decode('utf-8')</div><div>print(msg)</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># client.py</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.connect(('127.0.0.1', 8080))</div><div><br></div><div>sk.sendall(bytes('先服务端发送的数据', encoding='utf-8'))</div><div><br></div><div>sk.close()</div></div><div><span style="font-size:14pt;box-sizing:border-box;letter-spacing:normal;orphans:2;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;"><br></span></div></div><ul><li><div>sk.setblocking(True/False) -&gt;  设置socket的阻塞和非阻塞模式</div></li></ul><div><br></div><ul><ul><li><div>非阻塞模式就是遇见 listen 或 recv 都不进行阻塞直接往下执行</div></li></ul></ul><div><br></div><ul><ul><li><div>True: 阻塞 False: 非阻塞 默认值: True </div></li></ul></ul><div></div><ul><ul><li><div>将 socket 设置为非阻塞模式的时候，所有本来阻塞的程序都会变成非阻塞（如 sk.accept conn.recv），当程序执行的时候就会报错</div></li></ul></ul><div><br></div><div style="box-sizing:border-box;padding:8px;font-family:Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace;font-size:12px;color:rgb(51, 51, 51);border-radius:4px;background-color:rgb(251, 250, 248);border:1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div># server.py -&gt; 当 server 被启动的时候就会报错</div><div><br></div><div>import socket</div><div><br></div><div>sk = socket.socket()</div><div>sk.setblocking(False)  # 设置 socket 的阻塞和非阻塞模式</div><div>sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</div><div>sk.bind(('127.0.0.1', 8080))</div><div>sk.listen()</div><div>conn, addr = sk.accept()</div><div><br></div><div>msg = conn.recv(1024).decode('utf-8')</div><div>print(msg)</div><div><br></div><div>conn.close()</div><div>sk.close()</div></div><div><br></div><div><img data-filename="Image.png" src="/kevin-blog/Python/socket 模块_files/Image [2].png" type="image/png"></div><div><br></div></div><div><br></div></span></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/kevin-blog/Python/select IO多路复用模块.html" class="prev">
        select IO多路复用模块
      </a></span> <span class="next"><a href="/kevin-blog/Python/socketserver 模块.html">
        socketserver 模块
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/kevin-blog/assets/js/app.dd46475d.js" defer></script><script src="/kevin-blog/assets/js/2.97d04891.js" defer></script><script src="/kevin-blog/assets/js/222.e39491a9.js" defer></script>
  </body>
</html>
